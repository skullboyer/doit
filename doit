#!/usr/bin/bash
#@create:Tue Dec 23 20:43:17 CST 2025 by skull  ver:25.12.23.20.43
# Copyright © 2022-2025 <copyright skull.gu@gmail.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software
# and associated documentation files (the “Software”), to deal in the Software without
# restriction, including without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or
# substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
# BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

set +e

error_handler() {

    trap - ERR
    local exit_code=$?
    echo -e "\033[31mError occurred in line $LINENO <- ${BASH_LINENO[0]}:\033[0m Command: [ $BASH_COMMAND ] (Exit code: $exit_code)" >&2
    exit $exit_code
}

exit_handler() {
    stop_spin "exit."
    terminal_make
    exit 0
}

trap 'error_handler' ERR

trap 'exit_handler' SIGINT

trap 'exit_handler' EXIT

script_name=$(basename "${BASH_SOURCE[0]%.*}")

function help_info {
cat <<EOFHELP
*****************************************************************************************
** 首次使用本脚本，请在脚本文件所在路径下执行命令 ./dit hello，根据提示操作即可 ©skull **
*****************************************************************************************

usage: $script_name [init] [sync] [xml] [make] [gapp] [simul] [copy] [diff] [stash] [query] [tiny] [branch] [cp] [commit] [push] [cfg] [comple] [code] [clean] [hello] [tools] [git] [update]

初始化代码仓库
$script_name init [-b] [-x]
    -b  branch          后跟manifest仓分支，缺省则为master分支
    -x  xml             后跟要切换的xml配置文件，缺省则为huamiOS.xml

同步代码仓库
$script_name sync [--depth] [--repo] [--rebase]
    --depth             同步代码前净化代码仓(包括删除未跟踪内容)，不带--repo选项则同步所有仓
        {number}            回滚深度
    --repo              更新的代码仓范围
        [xml]               manifest仓处理
        [sport]             仅回退运动仓
        [all]               回退所有仓，否则仅回退CP过的代码仓
    --rebase            在当前节点下同步代码附带变基本地提交
    tips:               缺省参数则仅回退不干净的仓，并更新所有仓

xml操作
$script_name xml [-s] [-g] [-d]
    -s [-s/switch] [--branch] [--xml] {fallback-depth}
        --branch            切manifests仓分支
        --xml               要切换的xml配置文件
        {fallback-depth}    切换前净化代码仓的回滚深度，此参数可选
    -g [-g/generate]    生成当前代码节点xml
        {node}              打包代码指定节点xml
                            后可直接绝对时间'2024-08-24'，或相对时间'1w'
                            缺省则根据提示输入，若输入为空则节点即为当前日期
    -d [-d/diff] {old_xml} {new_xml}
        old_xml             生成代码差异changelog的旧节点xml
        new_xml             生成代码差异changelog的新节点xml

构建项目
$script_name make [-d] [-o] [-t] [-r] [-s] [-v] [--firmware-ota] [--backup] [--restore]
    -d  delta           增量编译
        --firmware-ota      增量固件OTA包
    -o  ota             ota全量包编译
    -t  tiny            制作差分包
    -r  release         release版本，缺省为debug版本
    -s  select          选择要构建的项目，缺省则在后面选择
    -v  version         指定版本号，版本号写在最后，缺省则为默认版本号：年.月.日.时.分
    --firmware-ota       单固件OTA包
    --backup            备份ota，为快速验证
    --restore           还原ota，为快速验证
    --skip              跳过编译，通常用于制作差分包或打固件升级包，如 -t, -fw
    tips:               缺省则进行代码编译(不带资源)，会将配置和版本号写入文件ota.version，方便追溯

生成gapp工程
$script_name gapp {module} [-c] [-s]
    module              指定要生成的gapp工程的模块
    -c  gapp module     选择要生成的gapp工程的模块
    -s  select          选择要构建的项目，缺省则在后面选择
    tips:               如果没有输入有效模块，则默认common模块

编译模拟器
$script_name simul [make] [--enter] [--remount] [--mount] [--umount] [--gapp] [--backup] [--restore]
    make                不带选项，非ota全量编译
        -d  delta           增量编译
        -o  ota             进行全量ota编译
        -a  assign          指定config所在目录
    --enter             模拟器启动进入校验
    --remount           全量编译后重新挂载
    --mount             挂载资源，可以做快速验证
    --umount            卸载资源
    --gapp              替换gapp文件，为快速验证
    --backup            备份ota，为快速验证
    --restore           还原ota，为快速验证

复制编译出的固件
$script_name copy [-t] [-o] [--fast] [-f] [-C] {product}
    -t  ota             复制ota升级固件到桌面对应项目文件夹
    -o  only            复制程序固件到对应项目烧录文件夹
    --fast              拷贝gapp、crc文件
    -f  force           更新存放固件的目录
    -C  assign          指定存放固件的项目名，缺省指定则使用 indicator.product
    product             指定要复制到文件夹的项目名，缺省则在后面选择
    tips:               缺省选项则复制包括资源在内的固件包到对应项目文件夹

检查代码仓变化
$script_name diff [-p] [-v] [-i] [-a] [-c] [-x] [--suffix] [--exclude] [--path] [--backup] [--xml] [--cp]
    -p  patch           应用补丁
        --repo-diff         指定repo.diff所在工程目录，缺省则应用当前工程中的补丁$script/repo.patch
    -i  ignore          检查仓内工作区所有文件修改情况
    -a  all             检查仓内所有文件修改情况，包括工作区、暂存区 (未进行编译同'-x'效果)
    -v  view            检查仓内工作区文件修改情况，同时在终端输出细节，可配合选项--suffix、--exclude使用
    -c  specify         检查指定文件变化的代码仓，格式：-c --file +file1 +file2 ...
                        检查指定文件类型变化的代码仓，格式：-c --suffix +type1 +type2 ...
    -x  untracked       检查仓内变化，包括未跟踪的文件，可使用格式：-x --suffix +type1 +type2 ... 来排除仅特定格式文件变化的仓以缩减有效范围，缺省则排除文件格式为'.gapp'
    --suffix            加入查看的文件类型，格式：--suffix +type1 +type2 ...
    --exclude           排除要查看的文件，格式：--exclude -file1 -file2 ...
    --path              检查指定目录关键字的代码仓文件修改情况，格式：-i/-a[-v] --path +sport +config
    --backup            备份文件$REPO_DIFF
    --xml               检查manifest仓
    --cp                检查cherriy-pick的提交改动，主要用于冲突时解决后检查正确性
    tips:               缺省则检查仓内默认格式c/cc/cpp/h文件修改情况，同时将结果写入文件$REPO_DIFF

处理代码仓暂存
$script_name stash [-a] [-d] [--apply-drop] [-v] [--view-summary] [--view-detail] [-s] [-m]
    -a  apply           应用贮藏修改
    -d  drop            丢弃贮藏修改
    --apply-drop        弹出贮藏修改
    -v  view            查看贮藏修改
    --view-summary      查看文件级别修改
    --view-detail       查看具体修改内容，结果存于$REPO_STASH_DIFF
    -s  save            贮藏diff命令查询到修改
    -m  messge          贮藏的注释（支持关键字匹配），可限定上述选项的执行范围
    tips:               执行结果写入文件$REPO_STASH，缺省则查看最近一周内暂存

查询代码仓日志信息
$script_name query [-f] [-p] [--depth] [--author] [--message] [--push]
    -f  find string     查询关键字符串的修改历史，结果写入query_result.txt
        {string}            格式：-f "string"，缺省仓路径则所有仓查找
        {repo-path}         格式：-f "string" [repo-path]，指定仓查找
    -p  push            检查仓内未push的提交，查询结果可见$QUERY_LOG
        --keep              续写多个关键字的未push查询结果
        --branch            检查在指定分支上未push的提交
        --key-word          可跟仓路径关键字查询，特殊关键字'all'为检查所有仓，缺省则默认是'sport'，必须作为最后参数
    --depth             指定查询深度，--author 最近几天 默认深度7天，--message 最近几笔 默认深度7笔
    --author            指定代码作者或提交者
    --message           指定提交时的描述信息
    --push              推送未push提交到远端仓库，基于-p选项的查询结果，亦可随-p选项一齐使用
    tips:               缺省所有参数（可指定深度）则查询自己最近一周的提交，查询结果写入文件$REPO_LOG

制作差分包
$script_name tiny [-p] [-t]
    -t  ota             复制ota升级固件到配置的ota目录的对应项目文件夹
    -p  product         指定做差分包的产品，缺省则以上次编译的产品做
    tips:               项目生成的升级包与bak/[product]文件夹中的升级包做差分包存至目录bak/[product]/diff，同时将上传至桌面文件夹[product]/tiny

代码仓分支操作
$script_name branch [-v] [-n] [-x] [-d] [-s]
    -v  view            查看指定分支存在的代码仓，若想看所有分支，可输入空 ''，""，' '，" "
    -n  exclude         查看指定分支不存在的代码仓
    -x  active          查看指定分支激活的代码仓
    -d  delete          删除指定分支
    tips:               上述选项后跟分支名，结果存入branch.tmp
    -s  switch          创建并切换分支
        --delete
        --create-all
        --create-local
        --create-remote
        --create-all-local
        {arg1}          仅携带这1个参数，则在指定仓中创建并切换到 arg1 分支
        {arg2}          多变参数
                            create-local 指定仓创建并切换到 arg1 分支
                            create-all-local 全仓创建并切换到 arg1 分支
        {arg3}          多变参数
                            delete 指定仓删除 arg2 分支并切换到 arg1 分支
                            create-all 全仓创建并切换到 arg1 分支，且跟踪远端 arg2 分支
                            create-remote 指定仓创建并切换到 arg1 分支，且跟踪远端 arg2 分支
    tips:               指定仓来源于分支查看命令-v -n -x

同步多笔提交
$script_name cp [-m] [--undo] [--check] [--fail] [--abort] [--merge] [--push] [--diff]
    -m                  支持同步的提交信息change-number、change-id、commit-hash、topic、hashtag
                            缺省则对非NEW状态的提交进行选择，提交状态：ABANDONED、MERGED、NEW
        --force             强制同步指定的所有提交
        --select            选择应用提交
        --count             统计代码的修改行数，不应用修改
        --squash            为压缩提交准备好分支，一般与选项 interact 一起使用，后续执行push命令推送压缩提交
        --interact          交互式同步，冲突时待解决后继续
        --test              同步测试，看下有没有冲突
    --undo              撤销同步的修改，缺省参数撤销的是最近一次同步的提交
        [assign]            撤销指定的同步提交，支持commit-id、change-number、change-id、topic、hashtag
            [preview]           预演撤销的仓库
    --check             查询cherry-pick到本地的提交，缺省参数即查看所有
        [verbose]           查看详细信息，包括提交者、提交时间等
        [push]              将check结果写入$REPO_DIFF准备提交
        {time}              查看指定深度的同步提交，使用方法 1：time [n] 或 time=n，2：不使用time 则需要将时间深度作为最后一个参数
                                绝对时间：HH:MM, YYYY-MM-DD, YYYY-MM-DD HH, YYYY-MM-DD HH:MM, YYYY-MM-DD HH:MM:SS
                                相对时间：1h: 1 hours ago, 1d: 1 days ago, 1w: 1 weeks ago
    --fail              检查同步失败的提交
    --abort             丢弃同步失败的提交
    --merge             解决完同步的冲突后，完成提交
        -v                  查看具体内容
        --no-push           只解冲突不push
    --push              推送同步的提交到远端，gerrit上无法同步时，可用于跨分支推送 (谨慎操作)
        -v                  查看具体内容
        --new-commit        同步提交作为新提交重新push
    --diff              以check为基准，查看修改明细，结果写入cp_check.diff
    tips:               topic对应的提交信息见记录topic_packet.txt，同步过程记录见topic_log.txt

提交多仓修改
$script_name commit [-m] [--log]
    -m                  推送提交
        {branch}            提交分支，必要
        {message}           提交信息，非必要，追加可省
        {topic}             归集多笔提交的标记，非必要
    --log               查询代码改动仓库提交log，后跟查询深度
    tips:               缺省选项参数可在后面输入，执行前须执行diff命令，支持各提交自定义分支、各提交文件选择、是否提交及跳过

推送提交
$script_name push [--depend] [--squash]
    --depend            指定推送提交的依赖文件
    --squash            压缩提交并推送，需配合 cp -m --squash

工具集合
$script_name tools [map] [crc] [display] [owner] [commit] [env]
    map                 解析各功能模块空间占用
        --parse  module     解析指定模块空间占用，后跟模块名
        --find  keyword     查看当前项目支持的指定关键字相关的模块，后跟模块关键字
        --exec  keyword     解析指定关键字相关的模块的空间占用，后跟模块关键字
        --sort              进行空间占用排序，分 RAM 和 ROM
        tips:               缺省则解析所有模块的空间占用
    crc
        {file.gapp}         计算文件crc
    display             查询产品显示尺寸，未指定则查询所有
        --assign            指定具体产品或关键字，缺省则后面输入
    owner               将分支或节点代码仓对比出的changelog，找出对应的owner附在每个提交的后面
        --deduplicate       去重 changlog，两节点都提交了、提交后Revert了、Merge了的都认为是重复的
            [only]              仅做去重处理
        --module            指定代码仓对应的模块关键字，指定后仅处理该关键字对应的仓库，当前支持关键字 sport，缺省则为全部
        --assign            指定提交者，缺省则指所有
        --type              指定提交类型
            [fix]               修复
            [feat]              需求
            [ref]               优化
        --out-format        指定输出格式，缺省则为text
            [md]                markdown，便于粘贴至文档
            [txt]               text，原文简要处理
            [csv]               excel格式，便于筛选
            [table]             表格，markdown格式，便于粘贴至文档
            [html]              网页格式，便于浏览、跳转
        -v                  同时在终端输出相关信息
        tips:               缺省则在原文副本添加owner
    commit              查询提交数量
        --name              提交人名，缺省为自己
        --state             提交代码状态
        --dedup             去除cherry-pick的提交
    env                 配置环境
        --repo              更新repo版本

创建配置文件
$script_name cfg [--fw-dir] [--mk-product] [--signature] [--history] [--commit-editor]
    --fw-dir            配置烧写、升级固件存放目录
        -s  show            展示当前配置的路径
        -w  write           修改存储路径
        -p  path            指定生成配置文件存放的路径，缺省则存放在该脚本所在目录
    --mk-product        创建产品列编译表文件，缺省参数则写入默认列表
        -d  delete          删除历史产品编译列表文件
        -e  empty           创建空的产品编译列表文件，前提是文件不存在
    --signature         创建签名存放路径
        -s  show            展示当前配置的路径
    --history           创建操作历史文件配置
    --commit-editor     创建提交信息编辑器方式
    tips:               按需修改即可

进行命令补全设置
$script_name comple [-w] [-p]
    -w  write env       将补全文件加入环境变量，执行完后需更新环境变量使之生效，source ~/.bashrc
    -p  path            补全文件存放路径，缺省则存放至用户路径即~
    tips:               缺省则仅生成补全文件，存放在本脚本所在位置

精简出trace所需的源码
$script_name code {src-path} {dest-path}
    src-path            代码仓目录，根目录
    dest-path           精简后的代码的存放路径（绝对路径），缺省则输出精简源码压缩包至代码仓根目录的上一级
    tips:               在代码仓根目录的上一级执行本命令，其他按照提示操作

删除本脚本产生的中间文件及编译出的文件
$script_name clean [--all]
    --all               删除vmmc.bin及切入build目录下make clean
    tips:               缺省则仅删除.$script_name和BACKUP

在散列代码仓使用git
$script_name git {arg}
    arg                 git支持的命令参数
    tips:               主要用在未被repo管控的散列代码仓使用git

更新脚本
$script_name update [-g] [-b]
    -g  generate        准备本地更新文件
        --force             配置为强制升级
    -b  backend         后台更新，适合周期性检查

EOFHELP
}

script=$0
script_name_with_path=$0
script_path=$(dirname "$0")
script_name_with_suffix=$(basename "$0")
script_name=${script_name_with_suffix%.*}

do_cmd=$1
last_cmd=${!#}
arg2=$2;arg3=$3;arg4=$4;arg5=$5;arg6=$6;arg7=$7;arg8=$8;arg9=$9
arg_count=$#

_EXEC_PARAMS=$@

EXEC_PARAMS=("$@")

EXEC_OPTIONS=("${@:2}")

current_path=`pwd`
BUILD_TYPE=release
version=`date +"%y.%-m.%-d.%-H.%M"`
debug_release=debug
enum_config=(
mhs003_matterhorn_defconfig
mhs003_milan_defconfig
mhs003_pamir_defconfig
mimxrt595_monaco_defconfig
mimxrt595_andes_defconfig
mimxrt595_vienna_defconfig
mimxrt595_teide_defconfig
mimxrt595_berlin_defconfig
)
enum_product_name=(
monaco
swift
swordfish
andes
teide
vienna
berlin
lille
res_tool
)
sport_modules=(
"framework/engine/sportEngine"
"packages/apps/sports"
"packages/services/sport"
"ui/Sports"
"ui/SportRecord"
"ui/SportSecondary"
"ui/SportStatus"
"ui/phn"
"ui/translations")
DOT_DIT=$current_path/.$script_name
DIT_PATH=$HOME/.$script_name
CFG_IN_DIR="/etc/dit"
[ -f $CFG_IN_DIR/gerrit ] && GERRIT_HOST=$(cat $CFG_IN_DIR/gerrit)
[ -f $CFG_IN_DIR/user ] && GERRIT_USER=$(cat $CFG_IN_DIR/user)
CODE_INFO="code.info"
OTA_VERSION="ota.version"
COMMIT_LOG="commit.log"
CP_LOG="cp.log"
CP_HISTORY_LOG="cp_history.log"
CP_FAIL="cp.fail"
CP_ABORT="cp.abort"
CP_CHECK="cp.check"
CP_UNDO="cp.undo"
REPO_LOG="repo.log"
REPO_DIFF="repo.diff"
REPO_STASH="repo.stash"
REPO_STASH_DIFF="repo.stash.diff"
QUERY_LOG="query.log"
HANDLE_HISTORY="handle.history"
MAKE_MENU=$DOT_DIT"/make.product"
MAKE_SIM_MENU=$DOT_DIT"/make.sim.product"
CHANGELOG_OUT=$DOT_DIT"/changelog_out"
BRANCH_RESULT="branch.txt"
SQUASH_DIR="squash_commit.dir"
DECONFIG_ORIGIN_VER=$DOT_DIT"/origin.version"
DECONFIG_PATH=$DOT_DIT"/deconfig.path"
source_dir='build/out/watch@*/binary'
flash_dir=/mnt/d/work/tools/02_download/pcfire
ota_dir=/mnt/d/ota
read_dir=/mnt/d/work/code
dir_cfg=$script_name-dir.cfg
sign_file_path="/mnt/d/work/sign"
[ -f $DIT_PATH/signature.path ] && sig_file=$(<$DIT_PATH/signature.path) || sig_file="$sign_file_path/sign.pem"
DEPEND_PATH=$DOT_DIT"/.depend/"
echo_cc() {
    local color="$1"
    local text="$2"
    case "$color" in
        -bk|black)  color_code="30" ;;
        -r|red)     color_code="31" ;;
        -g|green)   color_code="32" ;;
        -y|yellow)  color_code="33" ;;
        -b|blue)    color_code="34" ;;
        -p|purple)  color_code="35" ;; 
        -c|cyan)    color_code="36" ;; 
        -w|white)   color_code="37" ;;
        *)          color_code="39" ;; 
    esac
    echo -e "\033[1;${color_code}m${text}\033[0m"
}
echo_c() {
    local fg_color="" bg_color="" text=""
    for arg in "$@"; do
        case "$arg" in
            -bk|black)              fg_color="30" ;; 
            -r|red)                 fg_color="31" ;; 
            -g|green)               fg_color="32" ;; 
            -y|yellow)              fg_color="33" ;; 
            -b|blue)                fg_color="34" ;; 
            -p|purple|-m|magenta)   fg_color="35" ;; 
            -c|cyan)                fg_color="36" ;; 
            -w|white)               fg_color="37" ;; 
            -gry|gray|grey)         fg_color="90" ;; 
            -br|bright-red)         fg_color="91" ;; 
            -bg|bright-green)       fg_color="92" ;; 
            -by|bright-yellow)      fg_color="93" ;; 
            -bb|bright-blue)        fg_color="94" ;; 
            -bp|bright-purple)      fg_color="95" ;; 
            -bc|bright-cyan)        fg_color="96" ;; 
            -bw|bright-white)       fg_color="97" ;; 
            -bg-black)              bg_color="40" ;; 
            -bg-red)                bg_color="41" ;; 
            -bg-green)              bg_color="42" ;; 
            -bg-yellow)             bg_color="43" ;; 
            -bg-blue)               bg_color="44" ;; 
            -bg-purple|-bg-magenta) bg_color="45" ;; 
            -bg-cyan)               bg_color="46" ;; 
            -bg-white)              bg_color="47" ;; 
            -bg-gray|-bg-grey)      bg_color="100" ;; 
            -bg-bright-red)         bg_color="101" ;; 
            -bg-bright-green)       bg_color="102" ;; 
            -bg-bright-yellow)      bg_color="103" ;; 
            -bg-bright-blue)        bg_color="104" ;; 
            -bg-bright-purple)      bg_color="105" ;; 
            -bg-bright-cyan)        bg_color="106" ;; 
            -bg-bright-white)       bg_color="107" ;; 
            *) text="${text}${arg} " ;;
        esac
    done
    local color_code=""
    [[ -n "$fg_color" ]] && color_code="\033[1;${fg_color}m"  
    [[ -n "$bg_color" ]] && color_code="${color_code}\033[${bg_color}m" 
    echo -e "${color_code}${text}\033[0m"
}
test_echo_c() {
    echo "========== 基础前景色测试 =========="
    echo_c -bk "黑色文字 (black)"
    echo_c -r  "红色文字 (red)"
    echo_c -g  "绿色文字 (green)"
    echo_c -y  "黄色文字 (yellow)"
    echo_c -b  "蓝色文字 (blue)"
    echo_c -p  "紫色文字 (purple)"
    echo_c -c  "青色文字 (cyan)"
    echo_cc -w  "白色文字 (white)"
    echo ""
    echo "========== 亮色前景测试 =========="
    echo_c -gry "深灰文字 (gray)"
    echo_c -br  "亮红文字 (bright red)"
    echo_c -bg  "亮绿文字 (bright green)"
    echo_c -by  "亮黄文字 (bright yellow)"
    echo_c -bb  "亮蓝文字 (bright blue)"
    echo_c -bp  "亮紫文字 (bright purple)"
    echo_c -bc  "亮青文字 (bright cyan)"
    echo_c -bw  "亮白文字 (bright white)"
    echo ""
    echo "========== 背景色测试 =========="
    echo_c -w -bg-red    "白字红底"
    echo_c -y -bg-blue   "黄字蓝底"
    echo_c -r -bg-green  "红字绿底"
    echo_c -g -bg-purple "绿字紫底"
    echo_c -b -bg-yellow "蓝字黄底"
    echo_c -w -bg-cyan   "白字青底"
    echo ""
    echo "========== 亮背景测试 =========="
    echo_c -bk -bg-bright-yellow "黑字亮黄底"
    echo_c -br -bg-bright-white  "亮红字亮白底"
    echo_c -by -bg-bright-blue   "亮黄字亮蓝底"
    echo_c -bp -bg-bright-cyan   "亮紫字亮青底"
    echo ""
    echo "========== 混合 & 特殊字符测试 =========="
    echo_c -by -bg-purple "警告: Disk almost full!"
    echo_c -br -bg-gray "错误: 无法连接服务器!"
    echo_c -bg "成功: 文件已保存 ✅"
    echo_c -c "提示: 请按 Enter 继续..."
}
escape_for_grep() {
    local input="$1"
    local escaped
    escaped=$(printf '%s' "$input" | sed 's/[][\\\/$*.^|+?(){}"-]/\\&/g')
    printf '%s' "$escaped"
}
LOG_DEBUG=1
LOG_INFO=2
LOG_WARNING=3
LOG_ERROR=4
LOG_CTRL=$LOG_INFO
logF() {
    local log_ctrl=0
    local log_level="$1"
    local log_tag="$2"
    local log_msg="$3"
    log_tag="${log_tag#tag=}"
    [ -z $log_tag ] && log_msg="$2"
    case $log_level in
        -D)
            log_level="D"
            [ $LOG_CTRL -gt $LOG_DEBUG ] && log_ctrl=1
            ;;
        -I)
            log_level="I"
            [ $LOG_CTRL -gt $LOG_INFO ] && log_ctrl=2
            ;;
        -W)
            log_level="W"
            [ $LOG_CTRL -gt $LOG_WARNING ] && log_ctrl=3
            ;;
        -E)
            log_level="E"
            [ $LOG_CTRL -gt $LOG_ERROR ] && log_ctrl=4
            ;;
        *)
            log_tag="$1"
            log_tag="${log_tag#tag=}"
            [ -z $log_tag ] && log_msg="$1"
            ;;
    esac
    [ $log_ctrl -eq 0 ] && echo -e "$log_level> $(date '+%Y.%m.%d %H:%M:%S.%3N') ${log_tag:0:16} $log_msg" >>.$script_name/$script_name.log
}
log() {
    echo -e "$(date '+%H:%M:%S.%3N') $@"
}
log_i() {
    echo -e "I> $(date '+%H:%M:%S.%3N') $@"
}
log_w() {
    echo_c -y "W> $(date '+%H:%M:%S.%3N') $@"
}
log_e() {
    echo_c -r "E> $(date '+%H:%M:%S.%3N') $@"
}
log_assert() {
    [ $1 -ne 0 ] && {
        shift
        log_e "$@" "at line:${BASH_LINENO[0]}"
    }
}
diagnose_cmd() {
    if ! output=$(eval "$@" 2>&1); then
        local caller_lineno="${BASH_LINENO[0]}"
        echo "Error occurred on line $caller_lineno, command: $@" >&2
        logF -E tag="Diagnosis" "Error occurred on line $caller_lineno, command: $@"
        echo "Error details: $output" >&2
        logF -E tag="Diagnosis" "Error details: $output"
    fi
}
pulse_diagnosis() {
    target=$1
    content=$2
    [ "$content" = "$target" ] && {
        shift 2
        log_w "$@" "at line:${BASH_LINENO[0]}"
    }
}
check_last_cmd() {
    local ret=$?                               
    local threshold=${NEGATIVE_BOUNDARY:-250}  
    local msg="$1"                             
    if [[ $ret -lt $threshold ]]; then
        return 0
    else
        [[ -n "$msg" ]] && echo_c -r "❌ $msg (ret=$ret)" >&2
        return 1
    fi
}
contains_element() {
    local element match="$1"
    shift
    [[ $last_cmd = '?' ]] && echo "match  $match"
    for element; do
        [[ $last_cmd = '?' ]] && echo "element $element  ${match%%=*}"
        if is_number "$match"; then
            return 0
        fi
        [[ "${match%%=*}" == "${element%%=*}" ]] && return 0
    done
    return 1
}
strict_contains_element() {
    local element match="$1"
    shift
    for element; do
        [[ "match" == "element" ]] && return 0
    done
    return 1
}
is_valid_cmd() {
    contains_element "$1" "${EXEC_PARAMS[@]}"
    return $?
}
hit_option() {
    contains_element "$1" "${EXEC_PARAMS[@]}"
    return $?
}
hit_target() {
    contains_element "$1" "$@"
    return $?
}
sub_help() {
    $script help >.$script_name/help.info
    line_number=$(grep -n "$script_name $1" .$script_name/help.info |cut -d ':' -f1)
    awk -v start_line=$line_number 'NR>=start_line && /^$/{exit} NR>=start_line' .$script_name/help.info
    rm .$script_name/help.info
}
run_env_check() {
    local error=0
    local gerrit_name="$GERRIT_USER"
    local gerrit_service="$GERRIT_HOST"
    while :
    do
        [[ -n $gerrit_name || -n $gerrit_service ]] && {
            if ssh -p 29418 $gerrit_name@$gerrit_service 2>&1 |grep "you have successfully connected over SSH" >/dev/null; then
                [ $do_cmd = "hello" ] && ssh -p 29418 $gerrit_name@$gerrit_service 2>&1 |grep "Hi"
                break
            else
                error=1
                echo -e "\e[43m" "Hi buddy, there may be a mistake: " $gerrit_name $gerrit_service "\e[0m"
            fi
        }
        read -p "Is the gerrit server abnormal? [Y/N]: " select
        [[ $select = 'Y' ]] && return
        read -p "! Tell me gerrit-service name (xxx in gerrit.xxx.com): " gerrit_service
        gerrit_service="gerrit."$gerrit_service".com"
        if [ $error = 0 ]; then
            gerrit_name=$(wslvar USERNAME)
            continue
        else
            read -p "! Tell me your name (on Gerrit): " gerrit_name
            [ -z $gerrit_name ] && gerrit_name=$(wslvar USERNAME)
        fi
    done
    if [ $error = 0 ]; then
        echo $gerrit_name >user
        sudo mv user $CFG_IN_DIR
        echo $gerrit_service >gerrit
        sudo mv gerrit $CFG_IN_DIR/
    fi
}
extract_2_level_options() {
    cmd="$1"
    option="$2"
    help_file="$3"
    start_line=$(grep -nw "^$script_name $cmd" $help_file |head -n 1 | cut -d: -f1 | xargs)
    [[ -z $start_line ]] && return
    main_option_start_line=$(tail -n +"$start_line" "$help_file" | grep -nwE "^[[:space:]]{4}$option" |head -n 1 |cut -d: -f1 | xargs)
    line_number=$((start_line + main_option_start_line - 1))
    options=$(tail -n +"$line_number" "$help_file" | awk -v v_cmd="$cmd" -v v_opt="$option" '
        /^[ ]{4}[^[:space:]]/ {
            if ($1 == v_opt) {
                current_option = $1
                suboptions[current_option] = ""
            }
        }
        /^\s{8}-[a-zA-Z0-9]/ || /^\s{8}--/ {
            if (current_option != "") {
                suboptions[current_option] = suboptions[current_option] " " $1
            }
        }
        /^^[ ]{4}[^[:space:]]/ && $1 != v_opt {
            exit
        }
        END {
            result = ""
            for (v_cmd in suboptions) {
                result = result v_cmd ": " suboptions[v_cmd] "\n"
            }
            print result
        }')
    echo "$options"
}
option_check() {
    arg=$1
    [[ "$arg" = 'must' ]] && echo -e "\e[47m\e[31m!!Please check the input\e[0m" && exit -1
    [ -z "$arg" ] && return 0
    [ "$arg" = '?' ] && return 0
    [ "$arg" = '@' ] && return 0
    help_info >.$script_name/help.info
    args=$(grep -n "$script_name $do_cmd" .$script_name/help.info |grep -o '\[.*\]' |sed -e 's/\[//g'|sed -e 's/\]//g')
    readarray -t args <<<$args
    contains_element "$arg" ${args[@]}
    hint=$?
    rm .$script_name/help.info
    [[ $hint -ne 0 ]] && echo -e "\a\e[43m!!Please check command option.\e[0m" && exit -1
}
find_closest_option() {
    local input="$1"
    python3 -c "
import sys
from difflib import get_close_matches
input_str = sys.argv[1]
options = sys.argv[2].split()
def get_prefix_matches(word, possibilities):
    direct = [p for p in possibilities if p.startswith(word)]
    if direct:
        return direct
    word_clean = word.lstrip('-')
    if word_clean:
        for p in possibilities:
            p_clean = p.lstrip('-')
            if p_clean.startswith(word_clean):
                return [p]
    if word.startswith('-') and not word.startswith('--') and len(word) > 1:
        word_no_dash = word[1:]
        for p in possibilities:
            if p.startswith('--') and p[2:].startswith(word_no_dash):
                return [p]
    if len(word) < 3:
        sys.exit(0)
    return []
prefix_matches = get_prefix_matches(input_str, options)
if prefix_matches:
    print(prefix_matches[0])
    sys.exit(0)
matches = get_close_matches(input_str, options, n=1, cutoff=0.45)
if matches:
    print(matches[0])
else:
    print('')
" "$input" "${args[*]}"
}
options_check() {
    help_file=".$script_name/help.info"
    help_info >$help_file
    args=$(grep -n "$script_name $do_cmd" .$script_name/help.info |grep -o '\[.*\]' |sed -e 's/\[//g'|sed -e 's/\]//g')
    readarray -t args <<<$args
    local hint=unknown
    local invalid_option=""
    for arg in "${EXEC_OPTIONS[@]}"
    do
        [ "$arg" = '$' ] && continue
        [ "$arg" = '?' ] && continue
        [ "$arg" = '@' ] && continue
        contains_element "$arg" ${args[@]}
        [[ $? = 1 ]] && {
            local options=$(extract_2_level_options $do_cmd "$arg2" "$help_file")
            [[ $last_cmd = '?' ]] && echo "options  $options"
            contains_element "$arg" ${options[*]}
            [[ $? = 1 ]] && {
                [[ "$arg" != -* ]] && hint=ignore && break
                hint=false && invalid_option="$arg" && break
            }
        }
    done
    rm -f $help_file
    [ $hint = false ] && {
        suggestion=$(find_closest_option "$invalid_option")
        if [[ -n "$suggestion" ]]; then
            echo_c -y "Unknown option: '$invalid_option'. Did you mean: '$suggestion'?"
        else
            echo_c -y "Unknown option: '$invalid_option'"
        fi
        exit -1
    }
}
prompt_tone() {
    limit=$1
    cnt=0
    interval=1
    if [ $limit -lt 0 ]; then
        interval=0.3
        limit=5
    fi
    until [ $cnt -gt $limit ]
    do
        sleep $interval
        echo -e "\a\c"
        let cnt+=1
    done
}
progress_bar() {
    while :
    do
        echo -n '█'
        sleep 0.5
    done
}
spin_percent_file="/tmp/spin_percent_$BASHPID"
spin() {
    local -r delay='0.1'  
    local -r spinChars='-\|/'  
    local -r totalChars='4'  
    local i=0
    rm -f "/tmp/spin_percent"*
    while sleep $delay; do
        if [[ -f $spin_percent_file ]]; then
            local percent=$(< $spin_percent_file)
            printf '\r%s    [%d%%]' "${spinChars:i++%totalChars:1}" "${percent:-0}"
        else
            printf '%s\r' "${spinChars:i++%totalChars:1}"  
        fi
    done
}
pid=0
start_spin() {
    spin & 
    pid=$! 
}
start_spin_bar() {
    progress_bar &
    pid=$!
}
stop_spin() {
    [ $pid -eq 0 ] && return
    kill $pid > /dev/null 2>&1
    echo "$@"
}
compare_version() {
    local v1="$1"
    local v2="$2"
    IFS='.' read -r -a a1 <<< "$v1"
    IFS='.' read -r -a a2 <<< "$v2"
    local len=$(( ${#a1[@]} > ${#a2[@]} ? ${#a1[@]} : ${#a2[@]} ))
    for ((i=0; i<len; i++)); do
        local n1=${a1[i]:-0}
        local n2=${a2[i]:-0}
        if ((n1 > n2)); then
            return 1
        elif ((n1 < n2)); then
            return 2
        fi
    done
    return 0 
}
is_number() {
    local input=$1
    if [[ $input =~ ^-?[0-9]+\.?[0-9]*$ ]]; then
        return 0 
    else
        return 1 
    fi
}
convert_iso8601_time() {
    local input="$1"
    local result
    case "$input" in
        *y)
            local val=${input%y}
            result=$(date -d "$val year ago" "+%Y-%m-%d %H:%M:%S")
            ;;
        *m)
            local val=${input%m}
            result=$(date -d "$val month ago" "+%Y-%m-%d %H:%M:%S")
            ;;
        *w)
            local val=${input%d}
            result=$(date -d "$val week ago" "+%Y-%m-%d %H:%M:%S")
            ;;
        *d)
            local val=${input%d}
            result=$(date -d "$val day ago" "+%Y-%m-%d %H:%M:%S")
            ;;
        *h)
            local val=${input%h}
            result=$(date -d "$val hour ago" "+%Y-%m-%d %H:%M:%S")
            ;;
        *mm)
            local val=${input%mm}
            result=$(date -d "$val minute ago" "+%Y-%m-%d %H:%M:%S")
            ;;
        *s)
            local val=${input%s}
            result=$(date -d "$val second ago" "+%Y-%m-%d %H:%M:%S")
            ;;
        *)
            echo_c -r "Invalid format: $input"
            return 1
            ;;
    esac
    echo "$result"
}
convert_iso8601_date() {
    local input="$1"
    local result
    case "$input" in
        *y)
            local val=${input%y}
            result=$(date -d "$val year ago" "+%Y-%m-%d")
            ;;
        *m)
            local val=${input%m}
            result=$(date -d "$val month ago" "+%Y-%m-%d")
            ;;
        *w)
            local val=${input%d}
            result=$(date -d "$val week ago" "+%Y-%m-%d")
            ;;
        *d)
            local val=${input%d}
            result=$(date -d "$val day ago" "+%Y-%m-%d")
            ;;
        *)
            echo_c -r "Invalid format: $input"
            return 1
            ;;
    esac
    echo "$result"
}
get_git_dir() {
    local git_path=$(git rev-parse --absolute-git-dir)
    local repo_path=${git_path#*.repo/projects/}   
    repo_path=${repo_path%.git}            
    echo "$repo_path"
}
check_time_format() {
    local time_string=$1
    local years_ago='^[0-9]+y$'
    [[ $time_string =~ $years_ago ]] && echo "Y_Ago" && return
    local months_ago='^[0-9]+mo$'
    [[ $time_string =~ $months_ago ]] && echo "MO_Ago" && return
    local weeks_ago='^[0-9]+w$'
    [[ $time_string =~ $weeks_ago ]] && echo "W_Ago" && return
    local days_ago='^[0-9]+d$'
    [[ $time_string =~ $days_ago ]] && echo "D_Ago" && return
    local hours_ago='^[0-9]+h$'
    [[ $time_string =~ $hours_ago ]] && echo "H_Ago" && return
    local minutes_ago='^[0-9]+m$'
    [[ $time_string =~ $minutes_ago ]] && echo "M_Ago" && return
    local seconds_ago='^[0-9]+s$'
    [[ $time_string =~ $seconds_ago ]] && echo "S_Ago" && return
    local time_hm_regex='^[0-9]{2}:[0-9]{2}$'
    [[ $time_string =~ $time_hm_regex ]] && echo "HM" && return
    local date_regex='^[0-9]{4}-[0-9]{2}-[0-9]{2}$'
    [[ $time_string =~ $date_regex ]] && echo "YMD" && return
    local time_h_regex='^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}$'
    [[ $time_string =~ $time_h_regex ]] && echo "YMDH" && return
    local time_m_regex='^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}$'
    [[ $time_string =~ $time_m_regex ]] && echo "YMDHM" && return
    local time_s_regex='^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}$'
    [[ $time_string =~ $time_s_regex ]] && echo "YMDHMS" && return
    echo "time format unknown"
    return 1
}
time_result() {
    local time_input=$1
    if ! ret=$(check_time_format "$time_input"); then
        echo "$ret"
    fi
    local number=$(echo "$time_input" | awk -F'[^0-9]' '{print $1}')
    [[ $number -eq 0 ]] && ret="$time_input"
    case $ret in
        HM)
            echo "`date "+%Y-%m-%d"` $time_input"
            ;;
        YMD|YMDH|YMDHM|YMDHMS)
            echo "$time_input"
            ;;
        Y_Ago)
            echo "$number year ago"
            ;;
        MO_Ago)
            echo "$number month ago"
            ;;
        W_Ago)
            echo "$number weeks ago"
            ;;
        D_Ago)
            echo "$number day ago"
            ;;
        H_Ago)
            echo "$number hour ago"
            ;;
        M_Ago)
            echo "$number minute ago"
            ;;
        S_Ago)
            echo "$number second ago"
            ;;
        *)
            echo -e "\033[43mTime information input is incorrect\033[0m"
            echo "Legal style: year-month-day, hour:minute, 1y, 1mo, 1w, 1d, 1h, 1m, 1s"
            return 2
            ;;
    esac
}
OPTION_INDEX=0
OPTION_VALUE=""
get_option_index_and_value() {
    local option="$1"
    local index=-1
    local value=""
    local args=("${EXEC_PARAMS[@]}")
    for ((i = 0; i <= $arg_count; i++)); do
        arg="${args[$i]}"
        case $arg in
            $option=*)
                value="${arg#$option=}"
                index=$i
                ;;
            $option)
                if [[ $((i + 1)) -lt "${#args[@]}" && "${args[$((i + 1))]}" != -* ]]; then
                    value="${args[$((i + 1))]}"
                    index=$((i + 1))
                    ((i++)) 
                else
                    echo_c yellow "Warning: Option $option requires a non-empty value." >&2
                    return 1
                fi
                ;;
        esac
    done
    OPTION_INDEX=$index
    OPTION_VALUE=$value
    [ $last_cmd = '?' ] && echo "Index: "$OPTION_INDEX "Value: "$OPTION_VALUE
}
parse_options() {
    local option_count=0
    local option="$1"
    local tips="$2"
    local -a values=()
    local -a indices=()
    local args=("${EXEC_PARAMS[@]}")
    for ((i = 0; i < "${#args[@]}"; i++)); do
        arg="${args[$i]}"
        case $arg in
            $option=*)
                values+=("${arg#$option=}")
                indices+=("$i")
                ((option_count++))
                ;;
            $option)
                if [[ $((i + 1)) -lt "${#args[@]}" && "${args[$((i + 1))]}" != -* ]]; then
                    values+=("${args[$((i + 1))]}")
                    indices+=("$((i + 1))")
                    ((option_count++))
                    ((i++)) 
                else
                    [[ $tips = '?' ]] && echo_c yellow "Option: $option. requires a non-empty value" >&2
                    return -1
                fi
                ;;
        esac
    done
    OPTION_INDEX=("${indices[@]}")
    OPTION_VALUE=("${values[@]}")
    if [[ $last_cmd = '?' ]]; then
        echo "Index: ${OPTION_INDEX[*]}"
        echo "Values: ${OPTION_VALUE[*]}"
    fi
    [[ $option_count -eq 0 ]] && {
        [[ $tips = '?' ]] && echo_c yellow "Warning: Option $option unknown." >&2
        return -2
    }
    return $option_count
}
test_get_option() {
    get_option_index_and_value --name
    echo "index: "$OPTION_INDEX " value: "$OPTION_VALUE
    echo
    ret=$(parse_options --name)
    echo "\$?: "$?
    echo "ret: "$ret
    echo
    parse_options --name
    echo "\$?: "$?
    echo
    for i in "${!OPTION_INDEX[@]}"
    do
        echo "index: "${OPTION_INDEX[i]} " value: "${OPTION_VALUE[i]}
    done
    echo
    parse_options --value
    echo "\$?: "$?
    echo "value: "$OPTION_VALUE
    echo
    parse_options --name
    echo "\$?: "$?
    [[ ${OPTION_VALUE[@]} =~ 'boyer' ]] && echo "OPTION_VALUE: "${OPTION_VALUE[@]}
}
terminal_make() {
    [ ! -f $DECONFIG_PATH ] && return
    origin_version=$(< $DECONFIG_ORIGIN_VER)
    config_path=$(< $DECONFIG_PATH)
    sed -i '/BOARD_FIRMWARE_VERSION=/cBOARD_FIRMWARE_VERSION="'$origin_version'"' $current_path/$config_path
}
handle_history_file_order() {
    local handle_history=$DOT_DIT/$HANDLE_HISTORY
    [ ! -d $DOT_DIT ] && mkdir $DOT_DIT
    [ ! -f $handle_history ] && touch $handle_history
    local history_order=""
    [ -f $DOT_DIT/history.cfg ] && $(<$DOT_DIT/history.cfg)
    case $history_order in
        LIFO)
            tac $handle_history >handle_history.tmp
            echo $(date)" : \$$_EXEC_PARAMS " >>handle_history.tmp
            tac handle_history.tmp >$handle_history
            rm handle_history.tmp
            ;;
        FIFO)
            echo $(date)" : \$${EXEC_PARAMS[@]} " >>$handle_history
            ;;
        *)
            tac $handle_history >handle_history.tmp
            echo $(date)" : \$$_EXEC_PARAMS " >>handle_history.tmp
            tac handle_history.tmp >$handle_history
            rm handle_history.tmp
            ;;
    esac
}
simple_select_config() {
    index=0
    [ ! $1 ] && read -p "Please input product info: " keyword || keyword=$1
    [[ ! $keyword || $keyword == "q" ]] && exit 0
    while :
    do
        num=0
        for file in `find configs/ -iname "*$keyword*" |awk -F / '{print $NF}'`
        do
            echo "$num> $file"
            temp_config[num]=$file
            num=`expr $num + 1`
        done
        [ ! $file ] && echo -e "\nProduct name is incorrect, please re-enter!" && simple_select_config && break
        echo "q: exit"
        read -p "Please select product: " select
        [ $select = "q" ] && exit 0
        [[ $select =~ ^[0-9]+$ ]] && {
            config_select=${temp_config[$select]}
        } || {
            keyword=$select
        }
        [[ $config_select =~ "_defconfig" ]] && echo "config_select: "$config_select && break
    done
}
reduced_product_config() {
    for ((index=0; index<${#enum_config[@]}; index++))
    do
        echo "$index> ${enum_config[$index]}"
    done
    echo_c -c "\n--find: Direct search, skip the default list"
    echo_c -c "q/Q: Exit"
    read -p "Please select product or input keyword: " select
    [[ $select = "--find" ]] && simple_select_config && return
    [[ $select = "q" || $select = "Q" ]] && exit 1
    [[ $select =~ ^[0-9]+$ ]] && config_select=${enum_config[$select]} || {
        [[ ${enum_config[@]} =~ $select ]] && {
            local index=0
            local temp_product=()
            for value in "${enum_config[@]}"; do
                if [[ $value == *"$select"* ]]; then
                    temp_product+=($value)
                    ((index++))
                fi
            done
            [ $index -gt 1 ] && {
                enum_config=("${temp_product[@]}")
                reduced_product_config
            } || config_select=$value
        } || simple_select_config $select
    }
}
select_config() {
    index=0
    keyword=. 
    while :
    do
        num=0
        for file in `ls -1 $1 |grep $keyword`
        do
            echo "$num> $file"
            temp_config[num]=$file
            num=`expr $num + 1`
        done
        echo -e "\nx: backspace"
        echo "q: exit"
        read -p "Please select product or input keyword: " select
        [ $select = "q" ] && exit 1 || [ $select = "x" ] && {
            keyword=.
            [ $index -gt 0 ] && config_select=${directory_history[$((index--))]}
            continue
        }
        directory_history[$((++index))]=$config_select
        [[ $select =~ ^[0-9]+$ ]] && {
            config_select=${temp_config[$select]}
        } || {
            keyword=$select
        }
        [[ $config_select =~ "_defconfig" ]] && break
    done
}
product_config() {
    local arg=$1
    if [[ -n "$1" ]]; then
        select_config "$1"
    else
        reduced_product_config
    fi
    echo_c -y "config: $config_select\n"
}
git_fallback() {
    repo forall -c git reset --hard HEAD~$1
    echo -e "\n\e[42m ! The code rollback is complete \e[0m\n"
    repo forall -c git clean -df
    repo sync -j16
}
grep_branch() {
    repo forall -p -c 'git branch -vv |grep -w -q " "'$1' && git branch -vv' |tee .$script_name/$BRANCH_RESULT
}
grep_active_branch() {
    repo forall -p -c 'git branch --show-current |grep -w -q '$1' && git branch -vv' |tee .$script_name/$BRANCH_RESULT
}
grep_not_branch() {
    repo forall -p -c 'git branch -vv |grep -w -q " "'$1' || git branch -vv' |tee .$script_name/$BRANCH_RESULT
}
delete_branch() {
    repo forall -p -c 'git checkout --detach '$1'; git branch -D '$1'' |tee .$script_name/$BRANCH_RESULT
}
switch_branch() {
    [ -z $1 ] && echo "Please input correct arguments!" && exit -1
    [[ -n $1 && $2 = "--create-all-local" ]] && {
        repo forall -c git checkout -b $1
        return
    }
    [[ -n $1 && -n $2 && $3 = "--create-all" ]] && {
        repo forall -c git checkout -b $1 origin/$2
        return
    }
    cd .$script_name
    [[ -f dir.branch.tmp ]] || {
        [[ ! -f $BRANCH_RESULT ]] && echo "Make sure the target branch file exists!" && return -1
        grep project $BRANCH_RESULT >project.branch.tmp
        awk '{$1="";print $0}' project.branch.tmp > dir.branch.tmp
    }
    cd - >/dev/null
    while read line
    do
        echo_c -b "\n: $line"
        [[ -n $1 && -z $2 ]] && git -C $line checkout $1 && continue
        [[ -n $1 && $2 = "--create-local" ]] && git -C $line checkout -b $1 && continue
        [[ -n $1 && -n $2 && $3 = "--create-remote" ]] && git -C $line checkout -b $1 origin/$2 && continue
        [[ -n $1 && -n $2 && $3 = "--delete" ]] && git -C $line checkout $1 && git -C $line branch -D $2 && continue
    done < .$script_name/dir.branch.tmp
}
squash_commit_create_branch() {
    origin_branch="origin/$1"
    squash_commit_dir=$2
    while read line
    do
        echo_c -b ": "$line "\n"
        git -C $line checkout -b squash $origin_branch
        git -C $line checkout -b squash_draft $origin_branch
        echo ""
    done < $squash_commit_dir
}
_parse_dirctory() {
    dirconfig=`find /home ! -path '/home/skull/work/scripts/*' -iname $dir_cfg`
    if [ $dirconfig ]; then
        flash_dir=`grep -w flash-dir $dirconfig |awk -F : '{print $2}' |sed -e 's/^[ \t]*//g'`
        ota_dir=`grep -w ota-dir $dirconfig |awk -F : '{print $2}' |sed -e 's/^[ \t]*//g'`
        [ $do_cmd = "dircfg" ] && echo "flash directory: "$flash_dir && echo "ota directory: "$ota_dir
    else
        echo "固件存储路径配置文件不存在！"
    fi
}
parse_dirctory() {
    dirconfig="$CFG_IN_DIR/$dir_cfg"
    [[ ${EXEC_PARAMS[@]} =~ '--find' ]] && {
        [ -f ~/.$script_name/$dir_cfg ] && rm ~/.$script_name/$dir_cfg
        dirconfig=`find /home -iname $dir_cfg`
        echo "dirconfig: $dirconfig"
    }
    [ ! $dirconfig ] && echo "固件存储路径配置文件不存在！" && exit 0
    flash_dir=`grep -w flash-dir $dirconfig |awk -F : '{print $2}' |sed -e 's/^[ \t]*//g'`
    ota_dir=`grep -w ota-dir $dirconfig |awk -F : '{print $2}' |sed -e 's/^[ \t]*//g'`
    read_dir=`grep -w read-dir $dirconfig |awk -F : '{print $2}' |sed -e 's/^[ \t]*//g'`
    [[ $1 = "dircfg" ]] && {
        echo "flash directory: "$flash_dir
        echo "ota directory: "$ota_dir
        echo "read directory: "$read_dir
    }
}
copy_firmware() {
    [[ ${EXEC_PARAMS[@]} =~ '-C' ]] || {
        [[ ${enum_product_name[@]} =~ $last_cmd ]] || {
            for ((index=0; index<${#enum_product_name[@]}; index++))
            do
                echo "$index> ${enum_product_name[$index]}"
            done
            echo -e "\nq: exit"
            while :
            do
                read -p "Please select: " select
                [[ $select = "q" || $select = "Q" ]] && exit 1
                [[ $select =~ ^[0-9]+$ ]] || { echo "Enter a number"; continue; }
                if ((0 <= select && select < ${#enum_product_name[@]})); then
                    last_cmd=${enum_product_name[$select]}
                    break
                else
                    echo "Enter a valid number"
                fi
            done
        }
    }
    parse_dirctory
    source_dir=`echo $source_dir`
    [ $last_cmd = '-C' ] && last_cmd=$(cat .$script_name/bak/indicator.product)
    parent_dir=$(basename $(pwd))
    product_ota_dir=$ota_dir/$parent_dir
    [[ -d $source_dir ]] && {
        [[ ${EXEC_PARAMS[@]} =~ '--fast' ]] && {
            [ ! -d $product_ota_dir ] && mkdir -p $product_ota_dir
            cp $source_dir/ota/resources/Application.* $product_ota_dir/$last_cmd
            return 0
        }
        [[ ${EXEC_PARAMS[@]} =~ '-t' ]] && {
            [ ! -d $product_ota_dir ] && mkdir -p $product_ota_dir
            [ -d $product_ota_dir/$last_cmd ] && sudo rm -rf $product_ota_dir/$last_cmd
            mkdir $product_ota_dir/$last_cmd
            echo "copying..."
            start_spin_bar
            cp $source_dir/watch@*_sign.zip $product_ota_dir/$last_cmd
            cp $source_dir/watch@*.elf $product_ota_dir/$last_cmd
            rm $product_ota_dir/$last_cmd/watch@*.*.elf
            cp $source_dir/watch@*.map $product_ota_dir/$last_cmd
            cp $OTA_VERSION $product_ota_dir/$last_cmd
            echo -e "\n! ""OTA: "$product_ota_dir"/"$last_cmd
        } || {
            [[ ! -d $flash_dir ]] && echo -e "\a\e[43m!!!Please check the flash directory.\e[0m" && return -1
            [[ ${EXEC_PARAMS[@]} =~ '-o' ]] && {
                echo "copying..." && progress_bar &
                [ -d $flash_dir/$last_cmd/firmwarebin ] && {
                    cp $source_dir/watch@mimxrt595.bin $flash_dir/$last_cmd/firmwarebin/firmware.bin
                } || {
                    cp $source_dir/watch@mimxrt595.bin $flash_dir/$last_cmd
                    mv $flash_dir/$last_cmd/watch@mimxrt595.bin $flash_dir/$last_cmd/firmware_sign.bin
                }
            } || {
                [ $1 = 'all' ] && {
                    [ ! -d $flash_dir/$last_cmd ] && echo "!!Make sure the burn directory exists" && exit -1
                    echo "copying..."
                    start_spin_bar
                    cp -rf $source_dir/ramdump $flash_dir/$last_cmd/gt3_res/system
                    cp -rf $source_dir/extfw $flash_dir/$last_cmd/gt3_res/system
                    cp -rf $source_dir/ota/* $flash_dir/$last_cmd/gt3_res/system
                    [ -d $flash_dir/$last_cmd/firmwarebin ] && {
                        cp $source_dir/watch@mimxrt595.bin $flash_dir/$last_cmd/firmwarebin/firmware.bin
                    } || {
                        cp $source_dir/watch@mimxrt595.bin $flash_dir/$last_cmd
                        mv $flash_dir/$last_cmd/watch@mimxrt595.bin $flash_dir/$last_cmd/firmware_sign.bin
                    }
                }
            }
            echo -e "\n! ""FLASH: "$flash_dir"/"$last_cmd
        }
    } || echo -e "\a\e[43m!!!Please check the out directory.\e[0m"
    return 0
}
backup_firmware() {
    [ ! -d .$script_name/bak ] && mkdir .$script_name/bak
    [ -f .$script_name/bak/indicator.product ] && [ -f build/out/watch@mimxrt595/binary/watch@mimxrt595_ota_sign.zip ] && {
        cp build/out/watch@mimxrt595/binary/watch@mimxrt595_ota_sign.zip .$script_name/bak/`cat .$script_name/bak/indicator.product`
        cp $OTA_VERSION .$script_name/bak/`cat .$script_name/bak/indicator.product`
    }
    for product in ${enum_product_name[@]}
    do
        [[ $1 =~ $product ]] && break
    done
    [ $product = ${enum_product_name[-1]} ] && local product=$(echo "$1" | cut -d '_' -f 2)
    echo "backup: " $product
    echo $product >.$script_name/bak/indicator.product
    [ ! -d .$script_name/bak/$product ] && mkdir -p .$script_name/bak/$product/diff
    echo -e "\n\e[42mBackup firmware complete!\e[0m\n" 
}
dircfg() {
    sudo echo "Hi~ $GERRIT_USER"
    if [[ -n $1 ]]; then
        [ $1 = '-s' ] && {
            parse_dirctory dircfg
            return 0
        }
        [ $1 = '-w' ] && {
            local temp1
            echo "now flash path: " $flash_dir
            read -p "new flash path(default is keep): " temp1
            [ ! -d $temp1 ] && {
                read -p "The path does not exist, do you need to create it? Y/N: " answer
                [ $answer = 'Y' ] && mkdir $temp1
            }
            [ $temp1 ] && flash_dir=$temp1
            local temp2
            echo "now ota path: " $ota_dir
            read -p "new ota path(default is keep): " temp2
            [ ! -d $temp2 ] && {
                read -p "The path does not exist, do you need to create it? Y/N: " answer
                [ $answer = 'Y' ] && mkdir $temp2
            }
            [ $temp2 ] && ota_dir=$temp2
            local temp3
            echo "now read path: " $read_dir
            read -p "new read path(default is keep): " temp3
            [ ! -d $temp3 ] && {
                read -p "The path does not exist, do you need to create it? Y/N: " answer
                [ $answer = 'Y' ] && mkdir $temp3
            }
            [ $temp3 ] && read_dir=$temp3
            [[ -z $temp1 && -z $temp2 && -z $temp3 ]] && echo "Keep Default!" && return 1
            [[ ! -d $CFG_IN_DIR ]] && sudo mkdir $CFG_IN_DIR
        }
        [ $1 = '-p' ] && {
            [[ -z $2 ]] && echo "I think you should tell me something!" && return 1
            [[ ! -d $2 ]] && {
                echo ": $2"
                read -p "Do you want to create this directory?  [Y/N]: " choice
                [[ "$choice" != "Y" ]] && return 1
                sudo mkdir -p $2
                [[ $? != 0 ]] && return -1
            }
            read -p "Config Directory in '$2'  [Y/N]: " choice
            [[ "$choice" != "Y" ]] && return 1
            CFG_IN_DIR=$2
        }
    elif [[ ! -d $CFG_IN_DIR ]]; then
        read -p "Do you want to find the CFG directory?  [Y/N]: " choice
        [[ "$choice" != "Y" ]] && return 1
        echo "Finding..."
        start_spin
        cfg_path=`find /home -iname $script_name -type f`
        read -p "Config Directory in $cfg_path  [Y/N] " choice
        [[ "$choice" != "Y" ]] && return 1
        CFG_IN_DIR=${cfg_path%/*}
    else
        read -p "Do you want to set the default configuration information?  [Y/N]: " choice
        [[ "$choice" != "Y" ]] && return 0
    fi
    [ ! -f $dir_cfg ] && touch $dir_cfg
    cat>$dir_cfg<<EOF
@`date +"%Y-%m-%d %H:%M:%S"` by skull
#@pc工具烧写目录
flash-dir: $flash_dir
#@升级固件存放目录
ota-dir: $ota_dir
#@阅读代码存放目录
read-dir: $read_dir
EOF
    echo "============================================================="
    cat $dir_cfg
    sudo mv $dir_cfg $CFG_IN_DIR
    echo "cfg save done!"
}
update_product_list() {
    local input_file="$2"
    [ ! -f $input_file ] && return
    local query_string="$1"
    local max_lines=9
    local temp_file="$(mktemp)"
    local sorted_temp_file="$(mktemp)"
    while IFS=' ' read -r string frequency _; do
        local activated_product=""
        if [[ "$string" == "$query_string" ]]; then
            ((frequency++)) 
            activated_product="<-"
        fi
        printf "%s %d%s\n" "$string" "$frequency" "${activated_product:+ $activated_product}" >> "$temp_file" 
    done < "$input_file"
    sort -rn -k2 "$temp_file" > "$sorted_temp_file"
    if ! grep -q "^$query_string " "$sorted_temp_file"; then
        head -n "$max_lines" "$sorted_temp_file" > "$temp_file"
        printf "%s 1 <-\n" "$query_string" >> "$temp_file"
        mv "$temp_file" "$input_file"
    else
        mv "$sorted_temp_file" "$input_file"
    fi
}
update_watch_product_list() {
    update_product_list $1 "$MAKE_MENU"
}
update_sim_product_list() {
    update_product_list $1 "$MAKE_SIM_MENU"
}
get_current_branch() {
    local branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
    [ -z "$branch" ] && {
        local cnt=1
        while true; do
            branch=$(git rev-parse HEAD~$cnt |xargs git branch -r --contains |grep "\->" |awk -F "->" '{print $2}' |xargs)
            [ -n "$branch" ] && break
            (( cnt++ ))
            [ $cnt -gt 9 ] && break
        done
    }
    [ -n "$branch" ] && {
        local br_num=$(echo "$branch" |grep origin |wc -l)
        [ $br_num -eq 1 ] && {
            branch=${branch#*/}
            echo "$branch"
            return
        }
        echo "Maybe it helps: $branch"
    }
    [ -z "$branch" ] && echo -y "!!Remote branch not found"
    return 1
}
get_active_map_remote_branch() {
    local branch=$(git rev-parse --abbrev-ref --symbolic-full-name @{u})
    echo "$branch"
}
update_code_info() {
    if is_valid_cmd 'init'; then
        echo $(date) >.$script_name/$CODE_INFO
        branch_name=master
        if hit_option '-b'; then
            get_option_index_and_value -b
            local branch=$OPTION_VALUE
            if [[ -n "$branch" ]]; then
                branch_name="$branch"
            fi
        fi
        echo "branch: "$branch_name >>.$script_name/$CODE_INFO
        xml_name=huamiOS
        if hit_option '-x'; then
            get_option_index_and_value -x
            local xml=$OPTION_VALUE
            if [[ -n "$xml" ]]; then
                xml_name="$xml"
            fi
        fi
        echo "xml: "$xml_name >>.$script_name/$CODE_INFO
    elif is_valid_cmd 'sync'; then
        echo $(date) >.$script_name/$CODE_INFO
        cd .repo/manifests
        if ret=$(get_current_branch); then
            branch="$ret"
        else
            echo "$ret"
            branch="unKnown"
        fi
        cd - >/dev/null
        echo "branch: "$branch >>.$script_name/$CODE_INFO
        xml=$(sed -nE "s/.*['\"]([^'\"]*\.xml[^'\"]*)['\"].*/\1/p" .repo/manifest.xml)
        [[ -z $xml ]] && xml="unKnown"
        echo "xml: "$xml >>.$script_name/$CODE_INFO
    fi
}
count_code_line_from_gerrit() {
    local file=$1
    [ ! -f $file ] && echo "!!The file for counting code lines does not exist" && return 1
    local single_cnt=$2
    local total_insertions=0
    local total_deletions=0
    while read -r line; do
        if [[ $line =~ sizeInsertions:\ ([0-9]+) ]]; then
            total_insertions=$((total_insertions + BASH_REMATCH[1]))
        elif [[ $line =~ sizeDeletions:\ ([0-9]+) ]]; then
            total_deletions=$((total_deletions + BASH_REMATCH[1]))
        fi
    done <$file
    echo -e "\r\n"
    echo "Total insertions: $total_insertions"
    echo "Total deletions : $total_deletions"
    local commit_msg_lines=10
    local commit_cnt=$(grep -w "^rowCount:" $file |cut -d ':' -f2)
    echo "Commit count: "$commit_cnt
    echo "Code insertions: "$((total_insertions - commit_cnt * commit_msg_lines))
}
init_depend_file() {
    [ ! -d $DEPEND_PATH ] && mkdir -p $DEPEND_PATH
    local describe="// 格式要求如下
// module_name: dir1, dir2, dir3, ...
// sport: framework/engine/sportEngine, packages/apps/sports, packages/services/sport"
    echo -e $describe >$DEPEND_PATH/module_dir.dep
}
extract_option() {
    help_file="dit.sh"
    option="$1"
    main_option="$2"
    start_line=$(grep -nw "^\$script_name $option" "$help_file" |head -n 1 | cut -d: -f1 | xargs)
    echo "start_line: "$start_line
    main_option_start_line=$(tail -n +"$start_line" "$help_file" | grep  -nwE "^[[:space:]]{4}$main_option" |head -n 1 |cut -d: -f1 | xargs)
    echo -e "main_option_start_line: $main_option_start_line\n"
    line_number=$((start_line + main_option_start_line - 1))
    echo "line_number: "$line_number
    option=$(tail -n +"$line_number" "$help_file" | awk -v option="$option" -v main_option="$main_option" '
        /^[ ]{4}[^[:space:]]/ {
            if ($1 == main_option) {
                current_option = $1
                suboptions[current_option] = ""
            }
        }
        /^\s{8}-[a-zA-Z0-9]/ || /^\s{8}--/ {
            if (current_option != "") {
                suboptions[current_option] = suboptions[current_option] " " $1
            }
        }
        /^^[ ]{4}[^[:space:]]/ && $1 != main_option {
            exit
        }
        END {
            result = ""
            for (option in suboptions) {
                result = result option ": " suboptions[option] "\n"
            }
            print result
        }')
    echo "option: $option"
}
dollar_symbol() {
    echo "\$# "$# 
    echo "\$? "$? 
    echo "\$* "$* 
    echo "\$@ "$@ 
    echo "\$$ "$$ 
    echo "\$! "$! 
    echo "\$0 "$0 
    echo "\$n "$1 $2 $3 
}
test_instance() {
    shift
    echo_text=$(extract_2_level_options $1 $2)
    echo $echo_text
}
function dit-clean {
    mv .$script_name/$HANDLE_HISTORY .
    mv $MAKE_MENU .
    rm -rf .$script_name
    mkdir .$script_name && mv $HANDLE_HISTORY .$script_name
    [ $last_cmd = '--all' ] && {
        rm -rf vmmc.bin
        cd build && make clean
        cd - >/dev/null
    }
    return 0
}
function dit-init {
    branch_name=master
    if hit_option '-b'; then
        get_option_index_and_value -b
        local branch=$OPTION_VALUE
        if [[ -n "$branch" ]]; then
            branch_name="$branch"
        fi
    fi
    xml_name=huamiOS
    if hit_option '-x'; then
        get_option_index_and_value -x
        local xml=$OPTION_VALUE
        if [[ -n "$xml" ]]; then
            xml_name="$xml"
        fi
    fi
    git clone https://gerrit.googlesource.com/git-repo .repo/repo
    echo_c green "init..."
    repo init --repo-url=ssh://$GERRIT_USER@$GERRIT_HOST:29418/firmware/git-repo -u ssh://$GERRIT_USER@$GERRIT_HOST:29418/firmware/huamisys/manifest -b $branch_name -m ${xml_name}.xml
    echo_c green "sync..."
    repo sync -j16
    [ $? != 0 ] && return -1
    init_depend_file
    echo -e "\n\e[42mOver!\e[0m\n"
    return 0
}
function code_assign_node {
    local _date=$(date "+%Y-%m-%d")
    [ $1 = $last_cmd ] && {
        echo "1. "$_date
        read -p "input year: " _year
        read -p "input month: " _month
        read -p "input day: " _day
        [[ $_year && $_month && $_day ]] && {
            if [[ $_year -lt 100 ]]; then
                _year="20$_year"
            fi
            _month=$(printf "%02d" $_month)
            _day=$(printf "%02d" $_day)
            _date="${_year}-${_month}-${_day}"
            echo "2. "$_date
        } || {
            _date=$(date "+%Y%m%d_%H%M%S")
            echo "3. "$_date
            start_spin
            repo manifest -o manifest-$_date.xml -r
            echo "\"manifest-$_date.xml\" in `pwd`"
            return 0
        }
    } || {
        if ! _date=$(time_result $last_cmd); then
            echo "$_date"
            return -1
        fi
        echo "4. "$_date
    }
    start_spin
    readarray -t git_repo_dir < <(find . -type d -name ".git" | xargs -I {} dirname {})
    for dir in "${git_repo_dir[@]}"; do
        cd $dir
        commit=$(git log --date=short --pretty=format:"%ad %h" --before="$_date" | head -n 1 | cut -d " " -f2);
        git checkout $commit >/dev/null 2>&1
        cd - >/dev/null
    done
    DATE=$(date "+%Y%m%d_%H%M%S")
    specific_date=$(date -d "$_date" "+%Y%m%d")
    echo "5. "$DATE " "$specific_date
    repo manifest -o manifest-${DATE}__$specific_date.xml -r
    echo "\"manifest-$_date.xml\" in `pwd`"
    (repo sync >/dev/null 2>&1 && echo "" && prompt_tone 0) &
    return 0
}
function dit-xml {
    option_check $arg2
    case $arg2 in
        -s|switch)
            local clean=0
            if ! (git -C .repo/manifests diff --quiet && git -C .repo/manifests  diff --staged --quiet); then
                echo "!!XML repository is not clean"
                clean=1
            elif ! repo status | grep -q "nothing to commit"; then
                echo "!!Code repository is not clean"
                clean=1
            fi
            [ $clean -eq 1 ] && {
                read -p "Clean code repository [Y/n]: " input
                [[ "$input" = 'Y' ]] && $script sync --depth 9
            }
            [[ ${EXEC_PARAMS[@]} =~ '--branch' ]] && {
                get_option_index_and_value --branch
                manifest_branch=$OPTION_VALUE
            }
            [[ ${EXEC_PARAMS[@]} =~ '--xml' ]] && {
                get_option_index_and_value --xml
                manifest_xml=$OPTION_VALUE
            }
            [ ! $manifest_xml ] && {
                echo -e "\a!!! Please enter the product name."
                return -1
            }
            [[ $last_cmd =~ ^[0-9]+$ ]] && git_fallback $last_cmd
            echo "XML Switching..."
            [[ $manifest_branch ]] && {
                rm -rf .repo
                $script init -b=$manifest_branch -x=$manifest_xml
                return $?
            }
            repo init -m ${manifest_xml%.*}.xml
            echo -e "\n\e[42m===========================================================================================\e[0m\n"
            repo sync -c -j16
            ;;
        -g|generate)
            code_assign_node $arg2
            ;;
        -d|diff)
            local old=$arg3
            local new=$arg4
            [ ! $new ] && {
                read -p "input old.xml: " old
                read -p "input new.xml: " new
            }
            old=$(basename "$old" "${old##*.}")
            new=$(basename "$new" "${new##*.}")
            [ $last_cmd = '?' ] && echo "old "$old  "new "$new
            old=${old%.*}
            new=${new%.*}
            if [[ ! -d .repo/manifests ]]; then
                read -p "Please specify the path where the directory \".repo/manifests\" is located: " input
                if [[ -z "$input" ]]; then
                    echo_c -y "Input cannot be empty"
                    return 1
                fi
                manifests_path="$input/.repo/manifests"
                if [[ ! -d "$manifests_path" ]]; then
                    echo_c -y "error: dir $input no exsit"
                    return 1
                fi
                cp $old.xml $new.xml $manifests_path
                cd $manifests_path
            else
                cp $old.xml $new.xml .repo/manifests
                cd .repo/manifests
            fi
            if [[ $? -ne 0 ]]; then
                echo_c -y "cd error: dir .repo/manifests"
                return 1
            fi
            local _date=$(date "+%Y%m%d")
            repo diffmanifests $old.xml $new.xml >master_changelog-$_date.txt
            mv master_changelog-$_date.txt $current_path
            rm $old.xml $new.xml
            cd - >/dev/null
            absolute_path=$(realpath "master_changelog-$_date.txt")
            directory=$(dirname "$absolute_path")
            echo master_changelog-$_date.txt " in " $directory
            ;;
        *)
            echo -e "\n!!Please check the option parameters"
            ;;
    esac
    return 0
}
function dit-sync {
    option_check $arg2
    if hit_option '--depth'; then
        get_option_index_and_value --depth
        local depth=$OPTION_VALUE
        [[ ! $depth =~ ^[0-9]+$ ]] && depth=0
        if ! hit_option '--repo'; then
            git_fallback $depth
            return
        fi
    fi
    if hit_option '--repo'; then
        parse_options --repo
        if ! check_last_cmd; then
            return 1
        fi
        [[ ${OPTION_VALUE[@]} =~ 'xml' ]] && git -C .repo/manifests reset --hard HEAD~$depth
        [[ ${OPTION_VALUE[@]} =~ 'all' ]] && {
            git_fallback $depth
            return
        }
        [[ ${OPTION_VALUE[@]} =~ 'sport' ]] && {
            local branch=$(grep branch .$script_name/$CODE_INFO |cut -d " " -f2)
            for module in "${sport_modules[@]}"; do
                echo_c -b "  $module"
                git -C $module reset --hard HEAD~$depth
                git -C $module pull origin $branch
                echo
            done
            return
        }
        local sync_file=$(mktemp)
        if [ -f $DOT_DIT/$CP_CHECK ]; then
            cat $DOT_DIT/$CP_CHECK |grep -w "^project" |awk -F " " '{print $2}' >$sync_file
            [[ -z $depth ]] && depth=$(grep -o 'HEAD@{[0-9]*}' $DOT_DIT/$CP_CHECK |sed -E 's/HEAD@\{([0-9]*)\}/\1/' |sort -n |tail -1)
            echo $depth && return
        elif [ -f $DOT_DIT/$QUERY_LOG ]; then
            cat $DOT_DIT/$QUERY_LOG |grep -w "^project" |awk -F " " '{print $2}' >$sync_file
        else
            echo_c red "!! I think you should execute the cp --check command or the query command"
            return 1
        fi
        [ -s $sync_file ] && {
            echo_c green " rollback...."
            while IFS= read -r line; do
                git -C $line reset --hard HEAD~$depth
                git -C $line clean -fd
            done <$sync_file
            repo sync -d --force-sync -j16
        }
        rm $sync_file
    elif [[ $arg2 = '--rebase' ]]; then
        repo forall -c git pull --rebase
    else
        temp_file=$(mktemp)
        export temp_file 
        repo forall -p -c '
        [ -n "$(git status --porcelain)" ] && {
            echo "❌ 仓库 [$REPO_PATH] 存在未提交或未跟踪的文件！"
            echo $REPO_PATH >>$temp_file
            git status -s
        }'
        [ -s $temp_file ] && {
            echo -e "\n"
            read -p "⚠️ 要丢弃这些文件么[Y/n]: " input
            [[ "$input" != 'Y' ]] && rm $temp_file && return 1
            while IFS= read -r line; do
                git -C $line reset --hard HEAD
                git -C $line clean -fd
            done <$temp_file
            rm $temp_file
        }
        repo sync -d --force-sync -j16
    fi
    [ -f $DOT_DIT/$CP_HISTORY_LOG ] && rm $DOT_DIT/$CP_HISTORY_LOG
    return 0
}
function dit-make {
    option_check $arg2
    sudo rm -rf /usr/bin/python
    sudo ln -s /usr/bin/python3.8 /usr/bin/python
    [[ ${EXEC_PARAMS[@]} =~ '--backup' ]] && {
        [ -d build/out/watch@*/binary/ota ] && {
            start_spin
            [ -d ../firm-bk ] && rm -rf ../firm-bk
            mkdir ../firm-bk
            cp -r build/out/watch@* ../firm-bk
        } || echo -e "\nFirmware ota diectory do not exist!"
        return 0
    }
    [[ ${EXEC_PARAMS[@]} =~ '--restore' ]] && {
        start_spin
        [ -d build/out/watch@* ] && rm -rf build/out/watch@*
        [ -d ../firm-bk/watch@*/binary/ota ] && cp -r ../firm-bk/watch@* build/out || echo -e "\nFirmware ota diectory do not exist!"
        return 0
    }
    [ ! -f build/sign.pem ] && {
        [ ! -f $sig_file ] && {
            echo "!!Signature file does not exist"
            echo "Please execute the command  dit cfg --signature"
            return -1
        }
        cp $sig_file ./build
    }
    if hit_option '-t'; then
        [[ `pwd` =~ 'build' ]] || cd build
        [ ! -f ../.$script_name/bak/$product/watch@mimxrt595_ota_sign.zip ] && echo -e "\a\e[1;31merror: 没有可供生成差分包的原始文件！" || {
            python scripts/ota_gen_diff.py ./sign.pem ../.$script_name/bak/$product/watch@mimxrt595_ota_sign.zip out/watch@mimxrt595/binary/watch@mimxrt595_ota_sign.zip ../.$script_name/bak/$product/diff/watch@mimxrt595_ota_sign.zip
        }
        rm -rf sign.pem
        return
    fi
    [[ ${EXEC_PARAMS[@]} =~ '--skip' ]] || {
        if [[ ${EXEC_PARAMS[@]} =~ '-d' ]]; then
            [ ! -f build/.config ] && echo_c -y "!!missing config" && return 1
            local platform=$(grep HMI_BUILD_BOARD build/.config |awk -F "=" '{print $2}')
            echo -e "\n**platform: "$platform
            if [ "$platform" = \"mhs003\" ]; then
                sed -i '/.fw_ver       =/c.fw_ver       = "'$version'",'  platform/board/mhs003/init/board_bsd.c
            elif [[ $platform =~ "mimxrt595" ]]; then
                sed -i '/.fw_ver       =/c.fw_ver       = "'$version'",'  platform/board/mimxrt595/board_bsd.c
            elif [[ $platform = "apollo4" ]]; then
                sed -i '/.fw_ver       =/c.fw_ver       = "'$version'",'  platform/board/apollo4/board_bsd.c
            fi
        else
            [ -f $MAKE_MENU ] && readarray -t enum_config < <(cut -d' ' -f1 $MAKE_MENU)
            product_config
            update_watch_product_list $config_select
            backup_firmware $config_select
            cd build
            if [[ ! ${EXEC_PARAMS[@]} =~ '--firmware-ota' ]]; then
                make clean
                make distclean
            fi
            [[ ${EXEC_PARAMS[@]} =~ '-v' ]] && {
                echo "$last_cmd" |grep [^0-9.] >/dev/null || version=$last_cmd
            }
            [[ ${EXEC_PARAMS[@]} =~ '-r' ]] && debug_release=release
            [[ ${EXEC_PARAMS[@]} =~ '--version' ]] && {
                get_option_index_and_value --version
                version=$OPTION_VALUE
                echo "build version: "$version
            }
            deconfig=`find ../ -iname $config_select`
            local temp=$(mktemp)
            cp $deconfig $temp
            echo ${deconfig#*/} >$DECONFIG_PATH
            grep BOARD_FIRMWARE_VERSION $deconfig |cut -d '=' -f2 |tr -d '"' >$DECONFIG_ORIGIN_VER
            local deconfig_version=$(grep BOARD_FIRMWARE_VERSION $deconfig)
            sed -i '/BOARD_FIRMWARE_VERSION=/cBOARD_FIRMWARE_VERSION="'$version'"' $deconfig
            make $config_select BUILD_TYPE=$debug_release BUILD_FW_VER=$version
            cd - >/dev/null
            echo $config_select": "$version >$OTA_VERSION
        fi
        head -n 1 $OTA_VERSION > temp_$OTA_VERSION
        truncate -s 0 $OTA_VERSION
        mv temp_$OTA_VERSION $OTA_VERSION
        echo "delta version: "$version >>$OTA_VERSION
        echo "build info: "$debug_release" by "$GERRIT_USER" @"$(date) >>$OTA_VERSION
        [[ `pwd` =~ 'build' ]] || cd build
        if hit_option '-o'; then
            [[ $config_select =~ "mhs003" ]] && {
                local tmp="${config_select#mhs003_}"
                local product="${tmp%_defconfig}"
                echo "other core: build mhs003" >>../$OTA_VERSION
                [ -d out_hub ] && rm out_hub -rf
                make mhs003_${product}_sensorhub_defconfig APPDIR=out_hub
                make BUILD_DIR=out_hub APPDIR=out_hub
                cp out_hub/sensorhub@mhs003/binary/sensorhub@mhs003.bin ../platform/board/mhs003/products/${product}/sensorhub
                cp out_hub/sensorhub@mhs003/binary/sensorhub@mhs003_sign.bin ../platform/board/mhs003/products/${product}/sensorhub
                echo_c -g "Small core compilation completed!\n"
            }
            make ota -j16
        else
            make -j16
        fi
        local make_result=$?
        if [[ ${EXEC_PARAMS[@]} =~ '-d' ]]; then
            if [ "$platform" = \"mhs003\" ]; then
                sed -i '/.fw_ver       =/c\    .fw_ver       = SYSINFO_FIRMWARE_VER,'  ../platform/board/mhs003/init/board_bsd.c
            elif [ "$platform" = \"mimxrt595\" ]; then
                sed -i '/.fw_ver       =/c\    .fw_ver       = SYSINFO_FIRMWARE_VER,'  ../platform/board/mimxrt595/board_bsd.c
            elif [[ $platform = "apollo4" ]]; then
                sed -i '/.fw_ver       =/c\    .fw_ver       = SYSINFO_FIRMWARE_VER,'  ../platform/board/apollo4/board_bsd.c
            fi
        else
            mv $temp $deconfig
        fi
        [ $make_result != 0 ] && echo "!!make terminal" && rm -rf sign.pem && return -1
    }
    [[ ${EXEC_PARAMS[@]} =~ '--firmware-ota' ]] && {
        [[ `pwd` =~ 'build' ]] || cd build
        cp scripts/ota_gen_zip.py scripts/temp_ota_gen_zip.py
        sed -i '/hw_major_minor_ver = get_hw_version(config_file)/c\            fw_ver = "'$version'"\n            hw_major_minor_ver = get_hw_version(config_file)' scripts/ota_gen_zip.py
        python scripts/ota_gen_zip.py
        mv scripts/temp_ota_gen_zip.py scripts/ota_gen_zip.py
    }
    rm -rf sign.pem
    cd - >/dev/null
    return 0
}
function dit-simul {
    option_check $arg2
    sudo rm -rf /usr/bin/python
    sudo ln -s /usr/bin/python3.8 /usr/bin/python
    if [[ ${EXEC_PARAMS[@]} =~ '--enter' ]]; then
        echo "please input: auth 1, userdata 1"
        ./simulator/tool/shell_client
    elif [[ ${EXEC_PARAMS[@]} =~ '--gapp' ]]; then
        [ -f /mnt/vmmc/system/resources/Application.bin ] && sudo rm /mnt/vmmc/system/resources/Application.bin
        sudo sudo cp ui/prototype/Application/monaco/Application.gapp /mnt/vmmc/system/resources/
    elif [[ ${EXEC_PARAMS[@]} =~ '--mount' ]]; then
        simulator/tool/update_vmmc_simx86.sh ota vmmc.bin mount
    elif [[ ${EXEC_PARAMS[@]} =~ '--remount' ]]; then
        ./build/out/sim_app@simx86/binary/sim_app@simx86.elf -pimage,./vmmc.bin /mnt/system/resources/Application.gapp
        simulator/tool/update_vmmc_simx86.sh build/out/sim_app@simx86/binary/ota vmmc.bin
        simulator/tool/update_vmmc_simx86.sh ota vmmc.bin mount
    elif [[ ${EXEC_PARAMS[@]} =~ '--umount' ]]; then
        simulator/tool/update_vmmc_simx86.sh ota vmmc.bin umount
    elif [[ ${EXEC_PARAMS[@]} =~ '--backup' ]]; then
        [ ! -d build/out/sim_app@simx86/binary/ota ] && {
            echo -e "\nSimulator ota diectory do not exist!"
            return 1
        }
        start_spin
        [ -d ../simul-bk ] && rm -rf ../simul-bk
        mkdir ../simul-bk
        cp -r build/out/sim_app@simx86 ../simul-bk
    elif [[ ${EXEC_PARAMS[@]} =~ '--restore' ]]; then
        [ -d ../simul-bk/sim_app@simx86/binary/ota ] && {
            echo -e "\nSimulator ota diectory do not exist!"
            return 1
        }
        start_spin
        [ -d build/out/sim_app@simx86 ] && rm -rf build/out/sim_app@simx86
        cp -r ../simul-bk/sim_app@simx86 build/out
    elif [[ ${EXEC_PARAMS[@]} =~ 'make' ]]; then
        [ ! -f build/sign.pem ] && cp $sig_file ./build
        local sim_config_select=''
        if [[ ${EXEC_PARAMS[@]} =~ '-d' ]]; then
            cd build
            make JOBS=16
            [ $? != 0 ] && return -1
        else
            if [[ ${EXEC_PARAMS[@]} =~ '-a' ]]; then
                while :
                do
                    read -p "Enter the simulator configuration path: " sim_mk_path
                    [[ -d "$sim_mk_path" ]] && echo "$sim_mk_path" >"$DIT_PATH/sim.mk.cfg" && break
                    echo_c -y "The path does not exist, please check"
                done
            fi
            if [[ -f "$DIT_PATH/sim.mk.cfg" ]]; then
                sim_mk_path=$(< "$DIT_PATH/sim.mk.cfg")
                product_config "$sim_mk_path"
                sim_config_select=$config_select
                [ -f $MAKE_SIM_MENU ] && readarray -t enum_config < <(cut -d' ' -f1 $MAKE_SIM_MENU)
                product_config
                update_sim_product_list $config_select
            else
                product_config "configs/simulator"
            fi
            cd build
            if [[ ${EXEC_PARAMS[@]} =~ '-o' ]]; then
                make clean
                make distclean
                if [[ -n "$sim_config_select" ]]; then
                    make $config_select BUILD_SIM=$sim_config_select
                else
                    make $config_select
                fi
                make ota JOBS=16
                [ $? != 0 ] && return -1
                cd - >/dev/null
                [ -f vmmc.bin ] && rm vmmc.bin
                ./build/out/sim_app@simx86/binary/sim_app@simx86.elf -pimage,./vmmc.bin /mnt/system/resources/Application.gapp
                simulator/tool/update_vmmc_simx86.sh build/out/sim_app@simx86/binary/ota vmmc.bin
                simulator/tool/update_vmmc_simx86.sh ota vmmc.bin mount
                cd - >/dev/null
            else
                if [[ -n "$sim_config_select" ]]; then
                    make $config_select BUILD_SIM=$sim_config_select
                else
                    make $config_select
                fi
                make JOBS=16
                [ $? != 0 ] && return -1
            fi
        fi
        rm -rf ./build/sign.pem
        echo "build info: "$GERRIT_USER" @"$(date) >../$OTA_VERSION
    else
        echo "!!Please input option argument" && return 1
    fi
    return 0
}
function dit-gapp {
    option_check $arg3
    sudo rm -rf /usr/bin/python
    sudo ln -s /usr/bin/python3.8 /usr/bin/python
    product_config
    keyword=.
    [[ ${EXEC_PARAMS[@]} =~ '-c' ]] && {
        while :
        do
            echo -e "\n\e[32mPlease select the module name listed below:\e[0m"
            ls ui/ |grep -i $keyword |pr -3 -t
            read -p "select module: " module
            ls ui/ |grep -w $module && break || keyword=$module
        done
    }
    [[ $last_cmd == '-c' || $last_cmd == '-s' ]] || {
        storyboard_module=$last_cmd
        ls ui/ |grep -w "$storyboard_module" || unset storyboard_module
    }
    cd build
    make $config_select BUILD_TYPE=$debug_release
    if [[ -z $module ]]; then
        if [[ -z $storyboard_module ]]; then
            make -j16 prototype M=common
        else
            make -j16 prototype M=$storyboard_module
        fi
    else
        make -j16 prototype M=$module
    fi
}
function dit-copy {
    option_check $arg2
    copy_firmware all
    return 0
}
split_line="%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
function apply_patch {
    REPO_PATCH="repo.patch"
    [[ ${EXEC_PARAMS[@]} =~ '--repo-diff' ]] && {
        get_option_index_and_value --repo-diff
        [[ -f $OPTION_VALUE/.$script_name/$REPO_DIFF ]] && cp $OPTION_VALUE/.$script_name/$REPO_DIFF .$script_name/$REPO_PATCH
    }
    [[ ! -f .$script_name/$REPO_PATCH && ! -f .$script_name/$REPO_DIFF ]] && echo -e "\n!!Please exec diff command" && return 1
    grep -n $split_line .$script_name/$REPO_PATCH | awk -F ":" '{print $1-1}' | xargs -I{} sed -n '1,{}p' .$script_name/$REPO_PATCH >.$script_name/patch_project.tmp
    grep -w "^project" .$script_name/patch_project.tmp >.$script_name/patch_path_project.tmp
    [ ! -s .$script_name/patch_path_project.tmp ] && echo "** Nothing To Patch" && rm .$script_name/patch*.tmp && return 0
    patch_code_path=`awk -F " " '{print $2}' .$script_name/patch_path_project.tmp`
    [[ ${EXEC_PARAMS[@]} =~ '?' ]] && echo "patch_code_path $patch_code_path"
    grep -n $split_line .$script_name/$REPO_PATCH |awk -F ":" '{print $1}' |xargs -I{} sed -n '{},$p' .$script_name/$REPO_PATCH >.$script_name/patch_content.tmp
    [ ! -s .$script_name/patch_content.tmp ] && echo "** Nothing To Patch Content" && rm .$script_name/patch*.tmp && return 0
    patch_content_number=$(grep -nw "^project" .$script_name/patch_content.tmp |cut -d ':' -f1)
    readarray -t patch_content_number <<<$patch_content_number
    [[ $last_cmd = '@' ]] && {
        [[ -d .$script_name/patch ]] && rm -rf .$script_name/patch
        mkdir .$script_name/patch
    }
    readarray -t patch_code_path <<<$patch_code_path
    for ((index=0; index<${#patch_code_path[@]}; index++))
    do
        start_number=$(( ${patch_content_number[$index]} +1 ))
        [[ ${EXEC_PARAMS[@]} =~ '?' ]] && echo "* start_number $start_number"
        if [[ $index -lt $(( ${#patch_code_path[@]} - 1 )) ]]; then
            end_number=$(( ${patch_content_number[$((index + 1))]} -1 ))
            [[ ${EXEC_PARAMS[@]} =~ '?' ]] && echo "* end_number $end_number"
            sed -n "${start_number},${end_number}p" .$script_name/patch_content.tmp >.$script_name/temp.patch
            [[ $last_cmd = '@' ]] && sed -n "${start_number},${end_number}p" .$script_name/patch_content.tmp >.$script_name/patch/$index.patch
        else
            sed -n "${start_number},\$p" .$script_name/patch_content.tmp >.$script_name/temp.patch
            [[ $last_cmd = '@' ]] && sed -n "${start_number},\$p" .$script_name/patch_content.tmp >.$script_name/patch/$index.patch
        fi
        cd ${patch_code_path[$index]}
        [[ $last_cmd = '@' ]] && git apply --check $DOT_DIT/patch/$index.patch
        git apply --3way $DOT_DIT/temp.patch
        cd - >/dev/null
    done
    echo "patch count: "${#patch_code_path[@]}
    [[ $last_cmd = '@' ]] && {
        rm -rf .$script_name/patch
    }
    rm .$script_name/temp.patch
    return 0
}
function dit-diff {
    option_check $arg2
    [[ $last_cmd = '--backup' ]] && cp .$script_name/$REPO_DIFF .$script_name/repo_bk.diff && return 0
    [[ $arg2 = '-p' ]] && {
        apply_patch
        return $?
    }
    echo_c -b "diff..."
    start_spin
    echo "$"$do_cmd" "$arg2"  @"$(date) >.$script_name/$REPO_DIFF
    [[ $arg2 = '--cp' ]] && {
        [ ! -f .$script_name/$CP_LOG ] && echo "! You may need to cherry-pick the code first" && return 1
        read -ra repo_path < <(awk -F "]:" '{print $2}' .$script_name/$CP_LOG |awk -F '-' '{print $1}' |xargs)
        for ((index=0; index<${#repo_path[@]}; index++))
        do
            echo -e "\n[$index]- project ${repo_path[$index]}"
            echo -e "\nproject ${repo_path[$index]}" >>.$script_name/$REPO_DIFF
            git -C ${repo_path[$index]} show --stat |tee -a .$script_name/$REPO_DIFF
        done
        echo -e "\n\n"$split_line >> .$script_name/$REPO_DIFF
        for ((index=0; index<${#repo_path[@]}; index++))
        do
            git -C ${repo_path[$index]} diff HEAD >>.$script_name/$REPO_DIFF
        done
        return
    }
    type_filter='\.c$|\.cc$|\.cpp$|\.h$'
    type_filter_group=('*.c' '*.cc' '*.cpp' '*.h')
    file_exclude=('generated_sku.h')
    file_exclude_diff=(':!*generated_sku.h')
    [[ ${EXEC_PARAMS[@]} =~ '--path' ]] && {
        arg_position=0
        for arg in "$@"
        do
            arg_position=$((arg_position+1))
            if [ "$arg" = "--path" ]
            then
                arg_position=$((arg_position+1))
                break
            fi
        done
        for arg in "${@:$arg_position}"
        do
            if [[ $arg == +* ]]
            then
                file_type=${arg:1}
                path_keyword+=" -e $file_type"
            else
                break
            fi
        done
    }
    [[ ${EXEC_PARAMS[@]} =~ '--suffix' ]] && {
        arg_position=0
        for arg in "$@"
        do
            arg_position=$((arg_position+1))
            if [ "$arg" = "--suffix" ]
            then
                arg_position=$((arg_position+1))
                break
            fi
        done
        for arg in "${@:$arg_position}"
        do
            if [[ $arg == +* ]]
            then
                file_type=${arg:1}
                type_special+=" *.$file_type"
                type_filter+=" |\.$file_type$"
                type_filter_group+=("*.$file_type")
            else
                break
            fi
        done
    }
    [[ ${EXEC_PARAMS[@]} =~ '--exclude' ]] && {
        arg_position=0
        for arg in "$@"
        do
            arg_position=$((arg_position+1))
            if [ "$arg" = "--exclude" ]
            then
                arg_position=$((arg_position+1))
                break
            fi
        done
        for arg in "${@:$arg_position}"
        do
            if [[ $arg =~ ^-[^-].* ]]
            then
                file_type=${arg:1}
                file_exclude+=" -e $file_type"
                file_exclude_diff+=(" :!*$file_type")
            else
                break
            fi
        done
    }
    [[ ${EXEC_PARAMS[@]} =~ '--xml' ]] && {
        echo "project .repo/manifests/" >>.$script_name/$REPO_DIFF
        git -C .repo/manifests diff --stat |tee -a .$script_name/$REPO_DIFF
    }
    [[ ! $path_keyword ]] && path_keyword=.
    if [[ $arg2 = '-i' ]]; then
        repo forall -p -c 'if pwd |grep -i '"$path_keyword"' >/dev/null; then git diff --stat; fi' |tee -a .$script_name/$REPO_DIFF
        echo -e "\n\n"$split_line >> .$script_name/$REPO_DIFF
        repo forall -p -c 'if pwd |grep -i '"$path_keyword"' >/dev/null; then git diff; fi' >>.$script_name/$REPO_DIFF
        unset file_exclude
    elif [[ $arg2 = '-a' ]]; then
        repo forall -p -c '
            if pwd |grep -iq "'"$path_keyword"'"; then
                changed=$(git diff --name-only |grep -v -e '"$file_exclude"')
                if [ -n "$changed" ]; then
                    git status --porcelain |nl
                fi
            fi
        ' |tee -a .$script_name/$REPO_DIFF
        echo -e "\n\n"$split_line >> .$script_name/$REPO_DIFF
        repo forall -p -c '
            if pwd |grep -iq "'"$path_keyword"'"; then
                changed=$(git diff --name-only |grep -v -e '"$file_exclude"')
                if [ -n "$changed" ]; then
                    git diff
                fi
            fi
        ' >>.$script_name/$REPO_DIFF
        unset file_exclude
    elif [[ $arg2 = '-c' ]]; then
        if [[ ${EXEC_PARAMS[@]} =~ '--file' ]]; then
            for arg in "$@"
            do
                if [[ $arg == +* ]]
                then
                    file_name=${arg:1}
                    type_special+=" -e $file_name"
                fi
            done
            echo $type_special
            repo forall -p -c 'if git status --porcelain |grep -i '"$type_special"' >/dev/null; then git status --porcelain; fi' |tee -a .$script_name/$REPO_DIFF
        else
            type_special=$(echo $type_special | sed 's/\*.//g' | sed 's/ /|/g')
            repo forall -p -c 'if git status --porcelain |grep -E "\.('"$type_special"')$" >/dev/null; then git status --porcelain; fi' |tee -a .$script_name/$REPO_DIFF
        fi
        echo -e "\n\n"$split_line >> .$script_name/$REPO_DIFF
        unset file_exclude
    elif [[ $arg2 = '-x' ]]; then
        type_special=$(echo $type_special | sed 's/\*.//g' | sed 's/ /|/g')
        [ -z $type_special ] && type_special="gapp"
        repo forall -p -c 'if git diff --name-only |grep -vE "\.('"$type_special"')$" >/dev/null; then git status --porcelain; fi' |tee -a .$script_name/$REPO_DIFF
        echo -e "\n\n"$split_line >> .$script_name/$REPO_DIFF
        unset file_exclude
    fi
    [ ${#file_exclude[@]} -ne 0 ] && {
        [[ ${EXEC_PARAMS[@]} =~ '--path' ]] && {
            repo forall -p -c 'if pwd |grep -i '"$path_keyword"' >/dev/null; then git diff --stat; fi' |tee -a .$script_name/$REPO_DIFF
            echo -e "\n\n"$split_line >> .$script_name/$REPO_DIFF
            repo forall -p -c 'if pwd |grep -i '"$path_keyword"' >/dev/null; then git diff; fi' >>.$script_name/$REPO_DIFF
            return 0
        }
        [ $last_cmd = '?' ] && echo -e "\n* exclude file: $(declare -p file_exclude)\n"
        repo forall -p -c '
            changed=$(git diff --name-only |grep -E "'"$type_filter"'" |grep -v -e '"$file_exclude"')
            if [ -n "$changed" ]; then
                git diff --stat $changed
            fi
        ' |tee -a .$script_name/$REPO_DIFF
        echo -e "\n\n"$split_line >> .$script_name/$REPO_DIFF
        [ $last_cmd = '?' ] && echo -e "\n> git diff -- "${type_filter_group[*]} ${file_exclude_diff[*]}
        [[ $arg2 = '-v' ]] && {
            repo forall -p -c '
                changed=$(git diff --name-only |grep -E "'"$type_filter"'" |grep -v -e '"$file_exclude"')
                if [ -n "$changed" ]; then
                    git diff -- $changed
                fi
            ' |tee -a .$script_name/$REPO_DIFF
        } || {
            repo forall -p -c '
                changed=$(git diff --name-only |grep -E "'"$type_filter"'" |grep -v -e '"$file_exclude"')
                if [ -n "$changed" ]; then
                    git diff -- $changed
                fi
            ' >>.$script_name/$REPO_DIFF
        }
    }
    [[ ${EXEC_PARAMS[@]} =~ '--xml' ]] && git -C .repo/manifests diff >>.$script_name/$REPO_DIFF
    return 0
}
function dit-commit {
    option_check $arg2
    [[ $arg2 = '-m' && ! $arg3 ]] && echo -e "\e[43m\e[31m!!Please input commit branch\e[0m" && return -1
    backup_branch=$arg3
    [ ! -f .$script_name/$REPO_DIFF ] && echo -e "\n!!Please exec diff command" && return 1
    grep -n $split_line .$script_name/$REPO_DIFF | awk -F ":" '{print $1-1}' | xargs -I{} sed -n '1,{}p' .$script_name/$REPO_DIFF >.$script_name/commit_project.tmp
    grep -w "^project" .$script_name/commit_project.tmp >.$script_name/commit_path_project.tmp
    [ ! -s .$script_name/commit_path_project.tmp ] && echo "** Nothing To Submit" && rm .$script_name/commit*.tmp && return 0
    commit_code_path=`awk -F " " '{print $2}' .$script_name/commit_path_project.tmp`
    [[ $last_cmd = '?' ]] || rm .$script_name/commit*.tmp
    local temp_commit_log="$DOT_DIT/temp_commit.log"
    touch $temp_commit_log
    readarray -t commit_code_path <<<$commit_code_path
    [[ $last_cmd = '?' ]] && echo "commit_code_path  ${commit_code_path[@]}"
    local message=$arg4
    local topic=$arg5
    local bt=""
    local bk=""
    local repo_state=0
prompt_help="
*******************************************************************************************************
  Y: 确认本次提交，输入提交信息，如分支、描述、Topic，然后推送到远端仓库
  M: 挂载提交，将本次提交追加到gerrit上存在的指定的提交上去，会让你输入对应change-id
  N: 跳过本次提交，即什么也不敢，保持本地不变
  C: 追加提交，将本次修改追加到本地的上一笔提交，一般用来在同步到本地的提交上做修改
  B: 修改提交分支，常用来不同仓推到不同分支上
  A: 添加未跟踪文件，加入新增的文件
  X: 排除文件，去掉本次提交的部分文件
  V: 查看详细修改，确认本次提交修改的具体内容
  I: 提交信息核查，如分支、描述、Topic
  L: 查看提交历史，本地代码仓的提交描述历史
  G: 生成新提交，用于将同步到本地的提交结合本地修改，作为新提交推送
  O: 仅提交不推送，常用来将本次修改作为新提交，可在后续进行推送，亦可实现远端提交历史干净，或为了切分支，或再次同步提交等
  R: 同步提交时产生冲突，冲突解决后，完成解冲突状态，然后进行后续操作
  S: 单笔推送，如本地有多笔未推送的提交，直接推送会将多笔都推送，该选项用来仅推送指定commit-id的提交
  T: 查看代码仓状态
  E: 清除选项参数
  Q: 退出本次提交流程
"
prompt="
-------------------------------------------------------------------------------------------------------
 (Y)confirm commit    (M)mount commit    (N)skip commit    (C)amend commit         (B)change branch
 (A)add file          (X)exclude file    (V)view diff      (I)info check           (L)view log
 (G)new commit        (O)only commit     (S)single push    (R)resolve conflicts    (T)repository status
 (E)clear settings    (Q)exit"
    declare -A prompt_array
    while read -r part; do
        key=$(echo "$part" | sed -E 's/^\(([A-Z])\).*/\1/')
        val=$(echo "$part" | sed -E 's/^\([A-Z]\)[[:space:]]*(.*)/\1/')
        prompt_array["$key"]="$val"
    done < <(echo "$prompt" | grep -oP '\([A-Z]\)[^()]+')
    for ((index=0; index<${#commit_code_path[@]}; index++))
    do
        echo -e "\npath: "${commit_code_path[$index]}
        cd ${commit_code_path[$index]}
        [[ $arg2 = '--log' ]] && {
            [ $last_cmd = $arg2 ] && last_cmd=1
            git log --oneline -$last_cmd
            cd - >/dev/null
            continue
        }
        git status
        git add -u
        git status
        branch=$arg3
        local no_push="no"
        local commit_s_cmd=''
        local commit_amend_tag='no'
        while true
        do
            [[ ! $input ]] && {
                read -p "$(printf "%s $prompt \n\nYou Choice: ")" input
                local temp_input="$input"
            }
            [[ $last_cmd = '?' ]] && echo_c -c "Operation options: [$input] ${prompt_array[$input]}"
            case $input in
                Y|M)
                    [[ ! $branch ]] && bt=$input && input=I && continue
                    local temp_message=""
                    local result=$(git branch -a| grep "remotes/origin/$branch")
                    [ -z "$result" ] && unset input && unset branch && echo -e "\e[33m!!branch is invalid\e[0m" && continue
                    [[ ! $message ]] && {
                        echo_c purple "* Press 'Q' to return to the menu"
                        while :
                        do
                            read -p "> commit message: " temp_message
                            [ ! "$temp_message" ] && continue
                            message=$temp_message
                            break
                        done
                    }
                    [[ "$temp_message" = 'Q' ]] && unset input && continue
                    git commit -m "$message"
                    [[ $input = 'M' ]] && git commit --amend
                    input="push" && continue
                    ;;
                N)
                    echo -e "\e[43m\e[31m!!Skip this commit...\e[0m"
                    if [[ $bk = 'C' ]]; then
                        git reset HEAD@{1}
                    else
                        git reset
                    fi
                    break
                    ;;
                C)
                    commit_amend_tag='yes'
                    git commit --amend --no-edit
                    bt=$input && input="push" && continue
                    ;;
                B)
                    echo "> remote branch:"
                    git branch |grep detached && git branch -a |grep "\->" || git branch -vv
                    git branch -a |grep "\->"
                    read -p " new branch: " branch
                    ;;
                A)
                    git status -s
                    read -p " add untracked file: " untracked_file
                    git add $untracked_file
                    git status
                    ;;
                X)
                    git status -s
                    read -p " restore file: " restore_file
                    git reset $restore_file
                    git status
                    ;;
                V)
                    unset assign_file
                    read -p "> assign file: " assign_file
                    if [[ -n $assign_file && -f $assign_file ]]; then
                        if git status --porcelain -- "$assign_file" |grep '^??'; then
                            if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]; then
                                git diff NUL -- "$assign_file"
                            else
                                git diff /dev/null -- "$assign_file"
                            fi
                        elif git status --porcelain -- "$assign_file" | grep '^ [MD]'; then
                            git diff -- "$assign_file"
                        elif git status --porcelain -- "$assign_file" | grep '^[AMD]'; then
                            git diff --cached -- "$assign_file"
                        else
                            git status -v
                        fi
                    else
                        git status -v
                    fi
                    ;;
                I)
                    if ret=$(get_current_branch); then
                        branch="$ret"
                    else
                        echo "$ret"
                    fi
                    echo_c -g "The pre-filled commit message is as follows:"
                    echo " * Branch:   "$branch
                    echo " * Message:  $message"
                    echo " * Topic:    "$topic
                    echo_c purple "(If no modification is needed, press 'Enter'. To go back, input 'Q'.)"
                    read -p "> commit branch: " temp_branch
                    [[ $temp_branch == 'Q' || ( -z $temp_branch && -z $branch ) ]] && {
                        unset input
                        continue
                    }
                    [[ -n $temp_branch ]] && branch=$temp_branch
                    local temp_message=""
                    local editor=$(cat $CFG_IN_DIR/commit.edit 2>/dev/null)
                    editor=${editor:-0}
                    case "$editor" in
                        1)
                            tmpfile=$(mktemp)
                            echo -e "\nOpening vim... Please edit and save."
                            vim "$tmpfile"
                            temp_message=$(cat "$tmpfile")
                            rm "$tmpfile"
                            echo "> commit message:"
                            echo "temp_message"
                            ;;
                        *)
                            echo -e "\n> commit message (press Ctrl+D to finish):"
                            temp_message=$(cat)
                            ;;
                    esac
                    [ "$temp_message" = 'Q' ] && unset input && continue
                    [ "$temp_message" ] && message=$temp_message
                    echo -e "\n"
                    echo "(Keep, press 'Enter'. Clean, press 'Space'.)"
                    read -p "> commit topic: " temp_topic
                    [[ $temp_topic ]] && topic=$temp_topic
                    input=$bt && continue
                    ;;
                L)
                    local depth=1
                    while :
                    do
                        read -p "> log depth: " depth
                        [[ $depth =~ ^[0-9]+$ ]] || { echo "!!Only accept digital"; continue; }
                        break
                    done
                    git log -$depth
                    input=$bt && continue
                    ;;
                G)
                    [[ $bk = 'R' ]] || git commit --amend --no-edit
                    message=$(git log -1 --format=%s)
                    git reset HEAD^
                    git add -u
                    git status
                    input="Y" && continue
                    ;;
                O)
                    echo "* only commit not push"
                    no_push="yes"
                    ;;
                S)
                    [[ -z $commit_s_cmd ]] && {
                        echo_c -p "(press F to find, press Enter and empty as new commit)"
                        read -p "Enter the commit ID to be pushed: " commit_id
                        [[ -z $commit_id ]] && commit_s_cmd='NEW' && bt=$input && input=I && continue
                    }
                    [[ $commit_id = 'F' ]] && bt=$input && input='L' && continue
                    local remote_branch=$(grep branch $DOT_DIT/$CODE_INFO |cut -d' ' -f2)
                    git branch origin_single_push
                    git diff --quiet && git diff --cached --quiet
                    repo_state=$?
                    if [[ $repo_state -ne 0 ]]; then
                        git stash
                    else
                        [[ $commit_s_cmd = 'NEW' ]] && {
                            echo_c -y "There is no content to submit"
                            git checkout --detach origin_single_push
                            git branch -D origin_single_push
                            unset input && continue
                        }
                    fi
                    git checkout -b single_push --track origin/$remote_branch
                    [[ -z $commit_s_cmd ]] && git cherry-pick $commit_id
                    if [[ $repo_state -ne 0 ]]; then
                        git stash apply
                        [[ $commit_s_cmd = 'NEW' ]] && git add -u
help_single_push="
-------------------------------------------------------------------------------------------------------
  A: 添加要提交的文件
  X: 排除要提交的文件
  T: 查看当前仓状态
  V: 查看已添加的文件细节
"
prompt_single_push="
************************************************************************************************************************
 'A' add file, 'X' exclude file, 'T' view status, 'V' view diff, 'C' confirm commit, 'L' last once , 'Q' quit and abort
"
                        while true
                        do
                            echo_c -c "$prompt_single_push"
                            read -p "You choice: " choice
                            case "$choice" in
                                A)
                                    git status -s
                                    read -p " add submitted file: " submitted_file
                                    git add $submitted_file
                                    git status
                                    ;;
                                X)
                                    git status -sb
                                    read -p " restore file: " restore_file
                                    git restore --staged $restore_file
                                    git status
                                    ;;
                                T)
                                    git log -1
                                    git status
                                    ;;
                                V)
                                    unset assign_file
                                    read -p " assign file: " assign_file
                                    if [[ -n $assign_file && -f $assign_file ]]; then
                                        if git status --porcelain -- "$assign_file" |grep '^??'; then
                                            if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]; then
                                                git diff NUL -- "$assign_file"
                                            else
                                                git diff /dev/null -- "$assign_file"
                                            fi
                                        elif git status --porcelain -- "$assign_file" | grep '^ [MD]'; then
                                            git diff -- "$assign_file"
                                        elif git status --porcelain -- "$assign_file" | grep '^[AMD]'; then
                                            git diff --cached -- "$assign_file"
                                        else
                                            git status -v
                                        fi
                                    else
                                        git status -v
                                    fi
                                    ;;
                                C|L)
                                    if git ls-files -u | grep -q .; then
                                        echo_c -y "Merge conflicts exist, need to resolve"
                                        continue
                                    fi
                                    [[ -z $commit_s_cmd ]] && {
                                        commit_amend_tag='yes'
                                        git commit --amend --no-edit
                                    }
                                    [[ $commit_s_cmd = 'NEW' ]] && git commit -m "$message"
                                    repo_state='GOON'
                                    [[ $choice = 'L' ]] && {
                                        repo_state='OVER'
                                    }
                                    break
                                    ;;
                                Q)
                                    git reset --hard
                                    git checkout --detach origin_single_push
                                    git branch -D single_push origin_single_push
                                    git stash pop
                                    unset input && break
                                    ;;
                                *)
                                    echo_c -bg-white "$help_single_push"
                                    ;;
                            esac
                        done
                    fi
                    unset commit_s_cmd
                    [ -z "$input" ] && continue
                    [ -n "$input" ] && bt=$input && input="push" && continue
                    ;;
                R)
                    git add -u
                    git status
                    git cherry-pick --continue
                    ;;
                T)
                    echo_c -b "project "$(get_git_dir)
                    git status -sb
                    ;;
                E)
                    echo "* clear the settings"
                    no_push="no"
                    ;;
                Q)
                    if [[ $bk = 'C' ]]; then
                        git reset HEAD@{1}
                    else
                        git reset
                    fi
                    break 2 
                    ;;
                push)
                    [[ $no_push = "yes" ]] && echo_c yellow "no push" && break
                    if [[ $commit_amend_tag = 'yes' ]]; then
                        local change_id=$(git log -1 --format=%b |awk -F : '{print $2}' |xargs)
                        local ssh_info=$(ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set change:$change_id)
                        local temp_branch=$(echo "$ssh_info" |grep "branch:" |awk -F " " '{print $2}')
                        echo "amend branch: "$temp_branch
                        local branch_num=$(echo "$temp_branch" |wc -l)
                        [[ $branch_num -gt 1 ]] && {
                            readarray -t branches < <(echo "$temp_branch")
                            local number=0
                            for branch in "${branches[@]}"; do
                                echo "$number>: $branch"
                                ((number++))
                            done
                            read -p "Please select branch: " select
                            if [[ $select =~ ^[0-9]+$ ]]; then
                                temp_branch=${branches[$select]}
                            else
                                temp_branch="$select"
                            fi
                        }
                        while :
                        do
                            [ -z "$temp_branch" ] && read -p "> commit branch: " temp_branch
                            local result=$(git branch -a| grep "remotes/origin/$temp_branch")
                            [ -z "$result" ] && echo "! Branch Not Exist" && unset temp_branch && continue
                            branch=$temp_branch
                            break
                        done
                        local temp_topic=$(echo "$ssh_info" |grep "topic:" |awk -F " " '{print $2}')
                        echo "amend topic: "${temp_topic[0]}
                        topic=${temp_topic[0]}
                    fi
                    if ret=$(get_current_branch); then
                        current_branch="$ret"
                    fi
                    [[ $current_branch != $branch ]] && {
                        echo_c -c "\n!Local branch is inconsistent with push branch"
                        echo "local: "$current_branch
                        echo "push: "$branch
                        echo_c -y "!!You'd better not do that"
                        read -p "!!!Continue? [N/y]: " select
                        [[ $select != 'y' ]] && {
                            read -p "I think you should push this branch: $current_branch [Y/n]: " select
                            [[ $select != 'Y' ]] && {
                                if [[ $bt = 'S' ]]; then
                                    git reset --hard
                                    git checkout --detach origin_single_push
                                    git branch -D single_push origin_single_push
                                    [[ $repo_state -ne 0 ]] && git stash pop
                                else
                                    git reset
                                fi
                                unset input && continue
                            }
                            branch=$current_branch
                        }
                    }
                    git push origin HEAD:refs/for/$branch%topic=$topic 2>&1 |tee -a $temp_commit_log
                    status=${PIPESTATUS[0]}
                    if [[ $status -ne 0 ]]; then
                        echo_c -y "git push fail"
                        echo "Re-push after inspection"
                        if [[ $bt = 'C' ]]; then
                            git reset
                            unset input && continue
                        elif [[ $bt = 'S' ]]; then
                            git reset --hard
                            git checkout --detach origin_single_push
                            git branch -D single_push origin_single_push
                            git stash pop
                            unset input && continue
                        fi
                    fi
                    echo -e "project: "${commit_code_path[$index]} >>$temp_commit_log
                    if [[ $commit_amend_tag = 'yes' ]]; then
                        echo -e "- Amend Commit""\r\n" >>$temp_commit_log
                    else
                        echo -e "- New Commit""\r\n" >>$temp_commit_log
                    fi
                    echo -e "\r\n" >> $temp_commit_log
                    [[ $bt = 'S' ]] && {
                        git reset --hard
                        git checkout --detach origin_single_push
                        git branch -D single_push origin_single_push
                        if [[ $repo_state = 'GOON' ]]; then
                            git stash pop
                        elif [[ $repo_state = 'OVER' ]]; then
                            break
                        fi
                        unset input && continue
                    }
                    break
                    ;;
                *)
                    echo "$prompt_help"
                    ;;
            esac
            bk=$temp_input
            unset bt input
        done
        unset bt bk input
        arg3=$branch
        cd - >/dev/null
    done
    local size_commit_log=$(stat -c %s $temp_commit_log)
    [[ $size_commit_log -gt 0 ]] && {
        {
            echo $(date)
            echo $split_line
            cat $temp_commit_log
            [ -f $DOT_DIT/$COMMIT_LOG ] && cat $DOT_DIT/$COMMIT_LOG
        } > temp
        mv temp $DOT_DIT/$COMMIT_LOG
    }
    rm $temp_commit_log
    return 0
}
function dit-push {
    [[ ${EXEC_PARAMS[@]} =~ '--depend' ]] && {
        get_option_index_and_value --depend
        push_file=.$script_name/$OPTION_VALUE
        [ ! -f "$push_file" ] && echo_c -y "Missing File: $push_file" && return -1
        readarray -t repo_path < <(cat $push_file | grep -w "^project" | awk -F " " '{print $2}')
    }
    [[ ${EXEC_PARAMS[@]} =~ '--squash' ]] && {
        push_file=.$script_name/$SQUASH_DIR
        [ ! -f "$push_file" ] && echo_c -y "Missing File: $push_file" && return -1
        readarray -t repo_path < <(cat $push_file)
    }
    local branch=master
    for ((index=0; index<${#repo_path[@]}; index++))
    do
        echo_c -b "\n: ${repo_path[$index]}"
        cd ${repo_path[$index]}
        [[ ${EXEC_PARAMS[@]} =~ '--squash' ]] && {
            git branch -v
            while true
            do
                read -p "confirm branch Y: " input
                [ $input = 'Y' ] && break
            done
            git merge --squash squash_draft
            while true
            do
                echo -e "\n> (press Ctrl+D to finish.Keep, press 'Enter'. ) commit message:"
                local temp_message=$(cat)
                [ -n "$temp_message" ] && message="$temp_message" && break
                [ -n "$message" ] && break
            done
            git commit -m "$message"
            echo_c -c "(Keep, press 'Enter'. Clean, press 'Space'.)"
            while true
            do
                read -p "> (should not contain spaces.) commit topic: " temp_topic
                [ -n "$temp_topic" ] && topic="$temp_topic" && break
                [ -n "$topic" ] && break
            done
        } || git show --stat
        if ret=$(get_current_branch); then
            current_branch="$ret"
        else
            echo "$ret"
        fi
        echo "Branch: "$current_branch
        [ -n "$current_branch" ] && branch="$current_branch"
        unset enter
        read -p "$(echo_c -g '\nbranch: '"$branch"'\n'Confirm the submit:Y/N? or modify submit branch:M?): " enter
        [[ $enter = 'Q' || $enter = 'q' ]] && exit 0
        [[ $enter = 'M' ]] && {
            read -p "new branch name: " bn_enter
            branch=$bn_enter
            enter=Y
        }
        [[ $enter = 'Y' ]] && {
            git push origin HEAD:refs/for/$branch%topic=$topic 2>&1 |tee -a $DOT_DIT/push.log
        }
        cd - >/dev/null
    done
    return 0
}
function dit-stash {
    echo $(date)" : \$$_EXEC_PARAMS" >.$script_name/$REPO_STASH
    [ -z "$arg2" ] && {
        one_week_ago=$(date -d "7 days ago" +%s)
        export one_week_ago
        repo forall -p -c "
            git stash list --format='%gd|%at|%s' --date=iso |while IFS='|' read -r id date msg; do
                if [ \"\$date\" -ge \"\$one_week_ago\" ]; then
                    echo \"\$id  \$msg\"
                fi
            done
        " |tee -a .$script_name/$REPO_STASH
        return
    }
    local comment="."
    parse_options -m
    if check_last_cmd; then
        comment="$OPTION_VALUE"
    fi
    if hit_option '-a' || hit_option '--apply-drop'; then
        anser='Y'
        repo forall -p -c "git stash list |grep "$comment""
        echo -e "\n"
        read -p "\$ Confirm stash apply above Y/N: " anser
        echo -e "\n\n"$split_line >>.$script_name/$REPO_STASH
        [[ $anser && $anser = 'Y' ]] && {
            repo forall -p -c "git stash list |grep "$comment" |grep -o '{.*}' |sed -e 's/{//g' |sed -e 's/}//g' |xargs -I % git stash apply %" |tee -a .$script_name/$REPO_STASH
        }
        if ! hit_option '-d' || ! hit_option '--apply-drop' ]]; then
            return
        fi
    fi
    if hit_option '-d' || hit_option '--apply-drop'; then
        repo forall -p -c "git stash list |grep "$comment""
        echo -e "\n"
        read -p "\$ Confirm stash drop all Y/N: " anser
        [[ $anser && $anser = 'Y' ]] && {
            repo forall -p -c "git stash list |grep "$comment" |grep -o '{.*}' |sed -e 's/{//g' |sed -e 's/}//g' |xargs -I % git stash drop %" |tee -a .$script_name/$REPO_STASH
        }
        return
    fi
    [ $arg2 = '-v' ] && {
        repo forall -p -c "git stash list |grep "$comment"" |tee -a .$script_name/$REPO_STASH
        return
    }
    [ $arg2 = '--view-summary' ] && {
        repo forall -p -c "{
            brief=\$(git stash list --format=\"%gd|%at|%s\" --date=iso |grep "$comment")
            index=\$(git stash list |grep "$comment" |cut -d ':' -f1)
            [ \$index ] && echo \$brief && git stash show \$index
        }" |tee -a .$script_name/$REPO_STASH
        return
    }
    [ $arg2 = '--view-detail' ] && {
        repo forall -p -c "{
            index=\$(git stash list |grep "$comment" |cut -d ':' -f1)
            [ \$index ] && echo ":"\$index && git show \$index
        }" >>.$script_name/$REPO_STASH_DIFF
        return
    }
    [ $arg2 = '-s' ] && {
        grep -n $split_line .$script_name/$REPO_DIFF | awk -F ":" '{print $1-1}' | xargs -I{} sed -n '1,{}p' .$script_name/$REPO_DIFF |tee .$script_name/stash_project.tmp
        read -p "\$ Confirm stash above all Y/N: " anser
        [[ ! $anser || ($anser != 'N' && $anser != 'Y') ]] && echo "!!Invalid input" && return 1
        [ $anser = 'Y' ] && ansersub='Y'
        [ "$comment" = '.' ] && {
            while :
            do
                read -p "\$ Please input stash annotation: " comment
                [ -n "$comment" ] && break
            done
        }
        grep -w "^project" .$script_name/stash_project.tmp >.$script_name/stash_path_project.tmp
        stash_code_path=`awk -F " " '{print $2}' .$script_name/stash_path_project.tmp`
        readarray -t stash_code_path <<<$stash_code_path
        for path in ${stash_code_path[@]}
        do
            cd $path
            [ $anser = 'N' ] && git status && read -p "\$ Confirm stash this Y/N: " ansersub
            [ $ansersub = 'Y' ] && git stash push -m "$comment" |tee -a $DOT_DIT/$REPO_STASH
            cd - >/dev/null
        done
        echo "Stash Complete!"
    }
    return 0
}
function dit-query {
    option_check $arg2
    [[ $arg2 = '-p' ]] && {
        path_keyword=sport
        [[ ${EXEC_PARAMS[@]} =~ '--key-word' ]] && {
            get_option_index_and_value --key-word
            if [ $OPTION_VALUE = 'all' ]; then
                unset path_keyword
            else
                path_keyword=$OPTION_VALUE
            fi
        }
        [[ ${EXEC_PARAMS[@]} =~ '--branch' ]] && {
            get_option_index_and_value --branch
            seek_branch=$OPTION_VALUE
        }
        [ ! -f .$script_name/$QUERY_LOG ] && touch .$script_name/$QUERY_LOG
        [[ ${EXEC_PARAMS[@]} =~ '--keep' ]] || {
            [ -f .$script_name/$QUERY_LOG ] && rm .$script_name/$QUERY_LOG
            touch .$script_name/$QUERY_LOG
        }
        if [ -n "$seek_branch" ]; then
            start_spin
            query_mode=change
            base_dir=`pwd`
            export BASE_DIR="$base_dir"
            export PATH_KEYWORD="$path_keyword"
            export ENV_GERRIT_USER="$GERRIT_USER"
            export ENV_GERRIT_HOST="$GERRIT_HOST"
            export SEEK_BRANCH="$seek_branch"
            export QUERY_MODE="$query_mode"
            export ENV_QUERY_LOG="$DOT_DIT/$QUERY_LOG"
            export TMP_FILE=$(mktemp)
            repo forall -p -c ' {
                short_dir=$(realpath --relative-to="$BASE_DIR" "$PWD")
                if echo "$short_dir" | grep -i "$PATH_KEYWORD" >/dev/null; then
                    commitid=$(git log -1 --format=%H)
                    changeid=$(git log -1 | grep Change-Id: | awk "{print \$2}")
                    push_status=$(ssh -p 29418 "$ENV_GERRIT_USER@$ENV_GERRIT_HOST" gerrit query --current-patch-set "branch:$SEEK_BRANCH $QUERY_MODE:$changeid" | grep rowCount: | awk "{print \$2}")
                    if [ "$push_status" = 0 ] && [ -n "$changeid" ]; then
                        echo "\nproject $REPO_PATH \n** No Push: $changeid" >>"$TMP_FILE"
                        git log -1 --format=%s >>"$TMP_FILE"
                        git show "$commitid" --stat
                    fi
                fi
            }' >>.$script_name/$QUERY_LOG
            cat $TMP_FILE
            rm $TMP_FILE
        else
            query_mode=commit 
            start_spin
            base_dir=`pwd`
            repo forall -p -c "{
                short_dir=\$(realpath --relative-to=\"$base_dir\" \"\$PWD\")
                if echo \$short_dir |grep -i '"$path_keyword"' >/dev/null; then
                    commitid=\$(git log -1 |grep ^commit |awk '{print \$2}')
                    changeid=\$(git log -1 |grep Change-Id: |awk '{print \$2}')
                    push_status=\$(ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set \$query_mode \$commitid |grep rowCount: |awk '{print \$2}')
                    [ \$push_status = 0 ] && [ \$changeid ] && echo \"** No Push: \"\$changeid && git show \$commitid --stat
                fi
            }" |tee -a .$script_name/$QUERY_LOG
        fi
        [[ ${EXEC_PARAMS[@]} =~ '--push' ]] || return 0
    }
    [[ ${EXEC_PARAMS[@]} =~ '--push' ]] && {
        [ ! -f .$script_name/$QUERY_LOG ] && echo "!! I think you haven't executed the command \"$script_name query -p\" yet." && return -1
        readarray -t repo_path < <(cat .$script_name/$QUERY_LOG | grep -w "^project" | awk -F " " '{print $2}')
        readarray -t commit_id < <(cat .$script_name/$QUERY_LOG | grep -w "^commit" | awk -F " " '{print $2}')
        [[ ${#repo_path[@]} != ${#commit_id[@]} ]] && {
            echo -e "\033[43;37m !!The keyword 'project' does not match the number of 'commits' \033[0m"
            return -1
        }
        local branch=master
        for ((index=0; index<${#repo_path[@]}; index++))
        do
            echo -e "\n"
            cd ${repo_path[$index]}
            pwd
            if ret=$(get_current_branch); then
                current_branch="$ret"
            else
                echo "$ret"
            fi
            echo "Branch: "$current_branch
            [ -n "$current_branch" ] && branch="$current_branch"
            git show ${commit_id[$index]} --stat
            unset enter
            read -p "$(echo -e '\nConfirm the submit on <'"$branch"'>: Y/N?\nor modify submit branch: M?')  " enter
            [[ $enter = 'Q' || $enter = 'q' ]] && exit 0
            [[ $enter = 'M' ]] && {
                read -p "new branch name: " bn_enter
                branch=$bn_enter
                enter=Y
            }
            [[ $enter = 'Y' ]] && {
                git push origin ${commit_id[$index]}:refs/for/$branch
            }
            cd - >/dev/null
        done
        return 0
    }
    [[ $arg2 =~ '-f' ]] && {
        start_spin
        local repo_path=$arg4
        local file_hit_string="$DOT_DIT/hit_string"
        local file_query_result="$DOT_DIT/query_result.diff"
        if [[ $repo_path && $repo_path != '?' ]]; then
            cd $repo_path
            git log -p -G "$arg3" --name-only |tee $file_query_result
            readarray -t commits < <(cat $file_query_result |grep -w "^commit" |awk -F " " '{print $2}')
            for ((index=0; index<${#commits[@]}; index++))
            do
                readarray -t linenum < <(cat $file_query_result |grep -n "^commit" |awk -F ":" '{print $1}')
                git show ${commits[$index]} |grep "$arg3" -C 3 >$file_hit_string
                [[ $last_cmd = '?' ]] && cat $file_hit_string
                if [ $index -eq $((${#commits[@]} - 1)) ]; then
                    cat $file_hit_string >>$file_query_result
                else
                    local line_number=$((${linenum[$index+1]} - 2))
                    sed -i "${line_number}r $file_hit_string" $file_query_result
                fi
            done
        else
            repo forall -p -c git log -p -G "$arg3" --name-only |tee $file_query_result
            local file_project_commit="$DOT_DIT/project_commit"
            grep -w "^commit" -C 1 $file_query_result >$file_project_commit
            readarray -t commits < <(cat $file_query_result |grep -w "^commit" |awk -F " " '{print $2}')
            while read -r line; do
                local first_string=$(echo "$line" |awk -F ' ' '{print $1}')
                [[ $first_string == 'project' ]] && {
                    local process_project=$(echo "$line" |awk -F ' ' '{print $2}')
                    continue
                }
                [[ $first_string == 'commit' ]] && {
                    local process_commit=$(echo "$line" |awk -F ' ' '{print $2}')
                    [[ -f $file_hit_string ]] && {
                        local current_commit_line_number=$(cat $file_query_result |grep -n "$process_commit" |awk -F ":" '{print $1}')
                        local add_line_number=$(($current_commit_line_number - 2))
                        sed -i "${add_line_number}r $file_hit_string" $file_query_result
                    }
                    cd $process_project
                    git show $process_commit |grep "$arg3" -C 3 >$file_hit_string
                    echo -e "$split_line\n" >>$file_hit_string
                    [[ $last_cmd = '?' ]] && cat $file_hit_string
                    cd -
                }
            done <$file_project_commit
            cat $file_hit_string >>$file_query_result
            rm $file_project_commit
        fi
        rm $file_hit_string
        return 0
    }
    depth=7
    [[ ${EXEC_PARAMS[@]} =~ '--depth' ]] && {
        get_option_index_and_value --depth
        depth=$OPTION_VALUE
    }
    if [[ ${EXEC_PARAMS[@]} =~ '--author' ]]; then
        get_option_index_and_value --author
        author=$OPTION_VALUE
        repo forall -p -c git log --author="$author" --since="$(date -d "$depth day ago" +%Y-%m-%d)" --pretty=format:"%an %ad : %h %s" --date=short --no-merges --reverse |tee .$script_name/$REPO_LOG
    elif [[ ${EXEC_PARAMS[@]} =~ '--message' ]]; then
        get_option_index_and_value --message
        message=$OPTION_VALUE
        repo forall -p -c "git log -$depth --oneline |grep $message" |tee .$script_name/$REPO_LOG
    else
        repo forall -p -c git log --committer="$GERRIT_USER" --since="$(date -d "$depth day ago" +%Y-%m-%d)" --pretty=format:"%an %ad : %h %s %n" --date=short --no-merges --reverse |tee .$script_name/$REPO_LOG
    fi
    return 0
}
function dit-tiny {
    option_check $arg2
    sudo rm -rf /usr/bin/python
    sudo ln -s /usr/bin/python3.8 /usr/bin/python
    [ ! -f build/sign.pem ] && cp $sig_file ./build
    [[ $arg2 && $arg2 = '-p' ]] && {
        product=$arg3
    } || {
        [ -f .$script_name/bak/indicator.product ] && {
            product=`cat .$script_name/bak/indicator.product`
            echo "product: "$product
            [ ! -f .$script_name/bak/$product/watch@*_ota_sign.zip ] && {
                echo -e "\a\e[1;31merror: 没有可供生成差分包的目标文件！"
                return -1
            }
        }
    }
    [ -f build/out/watch@*/binary/watch@*_ota_sign.zip ] || {
        echo -e "\a\e[1;31merror: 没有可供生成差分包的原始文件！！"
        return -1
    }
    [ ! -d $DOT_DIT/bak/$product/diff ] && mkdir $DOT_DIT/bak/$product/diff
    cd build
    local target=(../.$script_name/bak/$product/watch@*_ota_sign.zip)
    local source=$(echo out/watch@*/binary/watch@*_ota_sign.zip)
    local tiny=($DOT_DIT/bak/$product/diff/watch@${product}_ota_sign.zip)
    echo "target: $target"
    echo "source: $source"
    echo "tiny: $tiny"
    python scripts/ota_gen_diff.py ./sign.pem ../.$script_name/bak/$product/watch@*_ota_sign.zip out/watch@*/binary/watch@*_ota_sign.zip $DOT_DIT/bak/$product/diff/watch@${product}_ota_sign.zip
    cd - >/dev/null
    [ $last_cmd = '-t' ] && copy_firmware
    [[ -d $ota_dir/$product/diff ]] && rm -rf $ota_dir/$product/diff
    mkdir -p $ota_dir/$product/diff
    cp $DOT_DIT/bak/$product/diff/watch@${product}_ota_sign.zip $ota_dir/$product/diff
    echo $(date) && return 0
    return 0
}
function dit-branch {
    option_check $arg2
    branch_name=$last_cmd
    [[ ${EXEC_PARAMS[@]} =~ '-v' ]] && {
        grep_branch $branch_name
    } || {
        [[ ${EXEC_PARAMS[@]} =~ '-n' ]] && {
            grep_not_branch $branch_name
        } || {
            [[ ${EXEC_PARAMS[@]} =~ '-x' ]] && {
                grep_active_branch $branch_name
            } || {
                [[ ${EXEC_PARAMS[@]} =~ '-d' ]] && {
                    delete_branch $branch_name
                } || {
                    [[ ${EXEC_PARAMS[@]} =~ '-s' ]] && {
                        switch_branch $arg3 $arg4 $arg5
                    }
                }
            }
        }
    }
    return 0
}
function dit-cp {
    option_check $arg2 must
    [ $arg2 = '--check' ] && {
        [[ ${EXEC_PARAMS[@]} =~ 'time' ]] && {
            get_option_index_and_value time
            input_time=$OPTION_VALUE
        } || {
            [ $arg2 != $last_cmd ] && {
                input_time=$last_cmd
            }
        }
        if [ -n "$input_time" ]; then
            if ! since_time=$(time_result $input_time); then
                echo "$since_time"
                return -1
            fi
            [[ ${EXEC_PARAMS[@]} =~ 'verbose' ]] && {
                repo forall -p -c "git log --walk-reflogs --since='$since_time' --pretty=format:'%h %ad %an %gs' |grep cherry-pick" |tee .$script_name/$CP_CHECK
            } || {
                repo forall -p -c "git reflog --since='$since_time' |grep cherry-pick" |tee .$script_name/$CP_CHECK
            }
        else
            [[ $arg3 && $arg3 = 'verbose' ]] && {
                repo forall -p -c "git log --walk-reflogs --pretty=format:'%h %ad %an %gs' |grep cherry-pick" |tee .$script_name/$CP_CHECK
            } || {
                repo forall -p -c 'git reflog |grep cherry-pick' |tee .$script_name/$CP_CHECK
            }
        fi
        [[ ${EXEC_PARAMS[@]} =~ 'verbose' ]] && {
            path_array=()
            hash_array=()
            while IFS= read -r line; do
                if [[ $line =~ ^project\ (.*) ]]; then
                    path="${BASH_REMATCH[1]}" 
                    while true; do
                        read -r next_line 
                        if [[ ! $next_line ]]; then
                            break
                        fi
                        path_array+=($path)
                        hash_array+=($(echo $next_line | awk '{print $1}')) 
                    done
                fi
            done <.$script_name/$CP_CHECK
            echo -e "\n\n"$split_line >>.$script_name/$CP_CHECK
            for ((i=0; i<${#path_array[@]}; i++)); do
                echo ${path_array[i]}
                echo ${hash_array[i]}
                cd ${path_array[i]}
                echo -e "\nproject: "${path_array[i]} >>$DOT_DIT/$CP_CHECK
                git show ${hash_array[i]} >>$DOT_DIT/$CP_CHECK
                cd - >/dev/null
            done
        }
        [[ ${EXEC_PARAMS[@]} =~ 'push' ]] && {
            cat .$script_name/$CP_CHECK >.$script_name/$REPO_DIFF
            echo -e "\n\n"$split_line >> .$script_name/$REPO_DIFF
        }
        return 0
    }
    [ $arg2 = "--fail" ] && {
        repo forall -p -c 'if git status |grep -q "cherry-picking"; then git status; fi' |tee .$script_name/$CP_FAIL
        return 0
    }
    [ $arg2 = "--abort" ] && {
        repo forall -p -c 'if git status |grep -q "cherry-picking"; then git cherry-pick --abort; fi' |tee .$script_name/$CP_ABORT
        return 0
    }
    [ $arg2 = "--merge" ] && {
        repo forall -p -c 'if git status |grep -q "cherry-picking"; then git status; fi' >.$script_name/$CP_FAIL
        readarray -t projects < <(grep "^project" .$script_name/$CP_FAIL |cut -d ' ' -f2)
        for project in "${projects[@]}"; do
            echo_c blue "\n  $project\n"
            cd $project
            [[ ${EXEC_PARAMS[@]} =~ '-v' ]] && git diff
            git add -u
            git cherry-pick --continue
            [[ ${EXEC_PARAMS[@]} =~ '--no-push' ]] && cd - >/dev/null && continue
            local change_id=$(git log -1 |grep Change-Id |awk -F " " '{print $2}')
            readarray -t branches < <(ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set change:$change_id |grep "branch:" |awk -F " " '{print $2}')
            local number=0
            for branch in "${branches[@]}"; do
                echo "$number>: $branch"
                ((number++))
            done
            read -p "Please select branch: " select
            [[ $select =~ ^[0-9]+$ ]] && branch=${branches[$select]}
            read -p "Confirm commit branch: $branch  [Y/N/M]: " choice
            if [[ $choice = 'Y' ]] ; then
                if ret=$(get_current_branch); then
                    current_branch="$ret"
                else
                    echo "$ret"
                fi
                [[ $current_branch != $branch ]] && {
                    echo -e "\n!Local branch is inconsistent with push branch"
                    echo "!!You'd better not do that"
                    read -p "!!!Continue? [N/y]: " select
                    [ $select != 'y' ] && {
                        read -p "I think you should push this branch: $current_branch [Y/n]: " select
                        [ $select != 'Y' ] && cd - >/dev/null && continue
                        branch=$current_branch
                    }
                }
                git push origin HEAD:refs/for/$branch
            elif [[ $choice = 'M' ]]; then
                read -p "Input commit branch: " branch
                git push origin HEAD:refs/for/$branch
            fi
            cd - >/dev/null
        done
        return 0
    }
    [ $arg2 = "--push" ] && {
        [ ! -s .$script_name/$CP_CHECK ] && echo_c yellow "! Please execute the --check option first" && return 1
        readarray -t projects < <(grep "^project" .$script_name/$CP_CHECK |cut -d ' ' -f2)
        for project in "${projects[@]}"; do
            echo_c blue "\n  $project\n"
            cd $project
            [[ ${EXEC_PARAMS[@]} =~ '-v' ]] && git show
            local change_id=$(git log -1 |grep Change-Id |awk -F " " '{print $2}')
            readarray -t branches < <(ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set change:$change_id |grep "branch:" |awk -F " " '{print $2}')
            local number=0
            for branch in "${branches[@]}"; do
                echo "$number>: $branch"
                ((number++))
            done
            read -p "Please select branch: " select
            [[ $select =~ ^[0-9]+$ ]] && branch=${branches[$select]}
            read -p "Confirm commit branch: $branch  [Y/N/M]: " choice
            if [[ $choice = 'Y' ]] ; then
                if ret=$(get_current_branch); then
                    current_branch="$ret"
                else
                    echo "$ret"
                fi
                [[ $current_branch != $branch ]] && {
                    echo -e "\n!Local branch is inconsistent with push branch"
                    echo "!!You'd better not do that"
                    read -p "!!!Continue? [N/y]: " select
                    [ $select != 'y' ] && {
                        read -p "I think you should push this branch: $current_branch [Y/n]: " select
                        [ $select != 'Y' ] && cd - >/dev/null && continue
                        branch=$current_branch
                    }
                }
            elif [[ $choice = 'M' ]]; then
                read -p "Input commit branch: " branch
            else
                cd - >/dev/null && continue
            fi
            [[ ${EXEC_PARAMS[@]} =~ '--new-commit' ]] && {
                message=$(git log -1 --format=%s)
                git reset HEAD^
                git add -u
                git status
                git commit -m "$message"
            }
            git push origin HEAD:refs/for/$branch
            cd - >/dev/null
        done
        return 0
    }
    [ $arg2 = "--diff" ] && {
        [ -s .$script_name/$CP_CHECK ] || {
            echo -e "\033[43;37m !!Execute the --check option first \033[0m"
            return -1
        }
        echo "diff check @ "$(date) >.$script_name/cp_check.diff
        awk '/^project / {if (NR!=1) print project, count; project=$0; count=0; next} {count+=gsub(/HEAD@/,"&")} END {print project, count}' .$script_name/$CP_CHECK >.$script_name/$CP_CHECK.tmp
        while IFS=' ' read -r -a line
        do
            [[ ${line[0]} = 'project' ]] && {
                echo -e "\n-${line[@]}" >>.$script_name/cp_check.diff
                cd ${line[1]}
                index=0
                until [ ! $index -lt ${line[2]} ]
                do
                    git show HEAD@{$index} >>$DOT_DIT/cp_check.diff
                    echo -e "\n--------------------------------------------------------------------------------\n" >>$DOT_DIT/cp_check.diff
                    index=`expr $index + 1`
                done
                git clean -df
                cd - >/dev/null
            }
        done <.$script_name/$CP_CHECK.tmp
        return 0
    }
    [ $arg2 = "--undo" ] && {
        [[ $arg3 = "assign" ]] && {
            [ "$last_cmd" = 'assign' ] && echo "!Seems like something is missing" && return -1
            local SSH_GET=".$script_name/cp_packet.txt"
            local PROCESS_RESULT=".$script_name/cp_project.tmp"
            get_option_index_and_value assign
            local ssh_token="$OPTION_VALUE"
            ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set change:$ssh_token >$SSH_GET
            grep -w "project:" $SSH_GET >$PROCESS_RESULT || {
                ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set commit:$ssh_token >$SSH_GET
                grep -w "project:" $SSH_GET >$PROCESS_RESULT || {
                    ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set topic:$ssh_token >$SSH_GET
                    grep -w "project:" $SSH_GET >$PROCESS_RESULT || {
                        ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set hashtag:$ssh_token >$SSH_GET
                        grep -w "project:" $SSH_GET >$PROCESS_RESULT || {
                            echo "!!Invalid commit info" && return -1
                        }
                    }
                }
            }
            [[ ! -f $SSH_GET || ! -f $PROCESS_RESULT ]] && echo "ssh request empty!" && return 1
            readarray -t projects < <(awk 'BEGIN{IGNORECASE=1} -F "project: firmware/huamiOS/" {print $2}' $PROCESS_RESULT)
            for project in "${projects[@]}"; do
                [[ ${EXEC_PARAMS[@]} =~ 'preview' ]] && echo "project: "$project && continue
                git -C $project reset --hard HEAD^
                repo sync $project
            done
            rm $SSH_GET
            rm $PROCESS_RESULT
            return 0
        }
        [ -f .$script_name/$CP_FAIL ] && rm .$script_name/$CP_FAIL
        touch .$script_name/$CP_FAIL
        repo forall -p -c 'if git status |grep -q "cherry-picking"; then pwd >>'$current_path'/.$script_name/$CP_FAIL; fi'
        wc -l .$script_name/$CP_FAIL >.$script_name/tmp.txt
        cherrypicking=$(awk '{print $1}' .$script_name/tmp.txt)
        rm .$script_name/tmp.txt
        echo "undo cherry-pick @ "$(date) >.$script_name/$CP_UNDO
        [ $cherrypicking -gt 0 ] && {
            while IFS= read -r line
            do
                echo -e "\n- $line" |tee -a $DOT_DIT/$CP_UNDO
                echo "**git cherry-pick --abort" |tee -a .$script_name/$CP_UNDO
                cd $line
                git cherry-pick --abort >>$DOT_DIT/$CP_UNDO 2>&1
                git clean -df
                cd - >/dev/null
            done <.$script_name/$CP_FAIL
        }
        [ -s .$script_name/$CP_CHECK ] || {
            echo -e "\033[43;37m !!Execute the --check option first \033[0m"
            return -1
        }
        awk '/^project / {if (NR!=1) print project, count; project=$0; count=0; next} {count+=gsub(/HEAD@/,"&")} END {print project, count}' .$script_name/$CP_CHECK >.$script_name/$CP_CHECK.tmp
        while IFS=' ' read -r -a line
        do
            [[ ${line[0]} = 'project' ]] && {
                echo -e "\n- ${line[@]}" |tee -a .$script_name/$CP_UNDO
                cd ${line[1]}
                git log --oneline -${line[2]} |tee -a $DOT_DIT/$CP_UNDO
                echo "**git reset --hard HEAD~${line[2]}" |tee -a $DOT_DIT/$CP_UNDO
                git reset --hard HEAD~${line[2]} >>$DOT_DIT/$CP_UNDO 2>&1
                git clean -df
                cd - >/dev/null
            }
        done <.$script_name/$CP_CHECK.tmp
        return 0
    }
    [ $arg2 = "-m" ] && {
        local SSH_GET=".$script_name/cp_packet.txt"
        local PROCESS_RESULT=".$script_name/cp_project.tmp"
        ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set change:$arg3 >$SSH_GET
        grep -w "project:" $SSH_GET >$PROCESS_RESULT || {
            ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set commit:$arg3 >$SSH_GET
            grep -w "project:" $SSH_GET >$PROCESS_RESULT || {
                ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set topic:$arg3 >$SSH_GET
                grep -w "project:" $SSH_GET >$PROCESS_RESULT || {
                    ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set hashtag:$arg3 >$SSH_GET
                    grep -w "project:" $SSH_GET >$PROCESS_RESULT || {
                        echo "!!Invalid commit info" && exit -1
                    }
                }
            }
        }
        [[ ! -f $SSH_GET || ! -f $PROCESS_RESULT ]] && echo "ssh request empty!" && return 1
        [ $last_cmd = '--count' ] && {
            count_code_line_from_gerrit $SSH_GET
            return $?
        }
        link_code_path=`awk -F " " '{print $2}' $PROCESS_RESULT` 
        project_dir=$(< $PROCESS_RESULT)
        OLD_IFS="$IFS"
        IFS=$'\n'
        project_dir=($project_dir)
        IFS="$OLD_IFS"
        readarray -t link_code_path <<<$link_code_path
        code_path=$(awk -v IGNORECASE=1 -F "huamiOS/" '
        {
            print (NF >= 2) ? $2 : $0
        }' $PROCESS_RESULT) 
        readarray -t code_path <<<$code_path
        [[ ${EXEC_PARAMS[@]} =~ '--squash' ]] && {
            local branch=$(grep branch .$script_name/$CODE_INFO |cut -d' ' -f2)
            printf "%s\n" "${code_path[@]}" >$SQUASH_DIR.temp
            awk '{count[$0]++} END {for (line in count) if (count[line] > 1) print line}' $SQUASH_DIR.temp |sort -u >$SQUASH_DIR
            squash_commit_create_branch $branch $SQUASH_DIR
            mv $SQUASH_DIR .$script_name
            rm -rf $SQUASH_DIR.temp
        }
        grep -w "open:" $SSH_GET >.$script_name/cp_project_open.tmp 
        readarray -t commit_opens < <(awk -F ":" '{print $2}' .$script_name/cp_project_open.tmp)
        grep -w -n "status:" $SSH_GET >.$script_name/cp_project_status.tmp 
        readarray -t commit_status < <(awk -F ":" '{print $3}' .$script_name/cp_project_status.tmp)
        readarray -t commit_status_line < <(awk -F ":" '{print $1}' .$script_name/cp_project_status.tmp)
        grep -w "ref:" $SSH_GET >.$script_name/cp_project_ref.tmp 
        commit_refs=`awk -F ":" '{print $2}' .$script_name/cp_project_ref.tmp`
        readarray -t commit_refs <<<$commit_refs
        grep -w "subject:" $SSH_GET >.$script_name/cp_project_subject.tmp 
        readarray -t commit_subject < <(awk -F ":" '{print $2}' .$script_name/cp_project_subject.tmp)
        echo "$"$do_cmd" "$arg2" "$arg3"  @"$(date) >.$script_name/$CP_LOG
        local cp_num=0
        for ((index = ${#link_code_path[@]} - 1; index >= 0 ; index--))
        do
            ((cp_num++))
            local open=${commit_opens[index]}
            local status=${commit_status[index]}
            local link=${link_code_path[index]}
            local refs=${commit_refs[index]}
            local path=${code_path[index]}
            local subject=${commit_subject[index]}
            if [[ $open =~ "true" ]] && ! hit_option "--select"; then
                local line_num=${commit_status_line[index]}
                local range=5
                local start_line=$((line_num - range))
                local end_line=$((line_num + range))
                local private=$(sed -n "${start_line},${end_line}p" $SSH_GET |grep -w "isPrivate:")
                [ -n "$private" ] && {
                    private_status=$(echo $private |awk -F ":" '{print $2}')
                    [ $private_status = 'true' ] && {
                        echo -e "\n[$cp_num] - project: "$link" - "$refs
                        echo "@Describe: " $subject
                        echo "status: "$status "  "$private
                        if [[ ${EXEC_PARAMS[@]} =~ '--force' ]]; then
                            : 
                        else
                            read -p "Confirm the use of this code [y/n]: " input
                            [[ $input != 'Y' ]] && echo "!! Abort" && continue
                        fi
                    }
                }
            else
                echo -e "\n[$cp_num] - project: "$link" - "$refs
                echo "@Describe: " $subject
                echo "status: "$status
                if [[ ${EXEC_PARAMS[@]} =~ '--force' ]]; then
                    : 
                else
                    read -p "Confirm the use of this code, or abort the rest [y/n/q]: " input
                    [[ $input = 'q' ]] && echo "!! Abort Rest" && break
                    [[ $input != 'y' ]] && echo "!! Abort This" && continue
                fi
            fi
            echo >>.$script_name/$CP_LOG
            echo "[$index]: "$path" - "$refs" - "$status >>.$script_name/$CP_LOG
            echo "@Describe: " $subject >>.$script_name/$CP_LOG
            [[ $path =~ 'firmware/Bluebox' ]] && path="framework/bluebox"
            cd $path
            echo -e "\n[$cp_num] -"${project_dir[index]}
            (git fetch ssh://$GERRIT_USER@$GERRIT_HOST:29418/$link $refs && git cherry-pick FETCH_HEAD) 2>&1 |tee -a $DOT_DIT/$CP_LOG
            status=${PIPESTATUS[0]}
            if [ $status -ne 0 ]; then
                echo_c -y "cherry-pick Conflict or Failure" |tee -a $DOT_DIT/$CP_LOG
                hit_option '--test' && git cherry-pick --abort
                hit_option '--interact' && {
                    while true
                    do
                        read -p "To continue press Y: " input
                        [ $input = 'Y' ] && echo "Interact: Processed Marker" >>$DOT_DIT/$CP_LOG && break
                    done
                }
            fi
            cd - >/dev/null
        done
        [ ! -f $DOT_DIT/$CP_HISTORY_LOG ] && touch $DOT_DIT/$CP_HISTORY_LOG
        (cat $DOT_DIT/$CP_LOG; printf '\n\n'; cat $DOT_DIT/$CP_HISTORY_LOG) >tmp && mv tmp $DOT_DIT/$CP_HISTORY_LOG
        [ $last_cmd = '?' ] || rm $SSH_GET
    }
    return 0
}
function map_sort {
    matches=$(grep -n "==========" .$script_name/map_parse_memory.txt)
    readarray -t matches <<<$matches
    line_numbers=()
    for match in "${matches[@]}"; do
        line_numbers+=( "$(cut -d: -f1 <<< "$match")" )
    done
    temp_file=$(mktemp)
    let N=${line_numbers[1]}+1
    let M=${line_numbers[2]}-1
    [ $last_cmd = '?' ] && echo "N: "$N "M: "$M
    sed -n "${N},${M}p" .$script_name/map_parse_memory.txt >$temp_file
    file_map_sort=.$script_name/map_sort.txt
    echo -e $(date)"\n" >$file_map_sort
    echo -e "ROM SORT:" >>$file_map_sort
    head -n ${line_numbers[1]} .$script_name/map_parse_memory.txt >>$file_map_sort
    sort -nr -k4 $temp_file >>$file_map_sort
    awk "NR>$M" .$script_name/map_parse_memory.txt >>$file_map_sort
    sed -n "${N},${M}p" .$script_name/map_parse_memory.txt >$temp_file
    echo -e "\r\nRAM SORT:" >>$file_map_sort
    head -n ${line_numbers[1]} .$script_name/map_parse_memory.txt >>$file_map_sort
    sort -nr -k6 $temp_file >>$file_map_sort
    awk "NR>$M" .$script_name/map_parse_memory.txt >>$file_map_sort
    cat $file_map_sort
    rm $temp_file
}
function map {
    start_spin
    map_file=$(find . -type f -name "watch@*.map")
    [ ! map_file ] && echo -e "\n!!No compiled map file found" && exit 0
    cp $scripts_path/map_memory_parse_gcc.py .
    module=$arg4
    case $arg3 in
        --parse)
            python map_memory_parse_gcc.py $map_file $module |tee .$script_name/map_parse_memory.txt
            ;;
        --find)
            python map_memory_parse_gcc.py $map_file find $module |tee .$script_name/map_parse_memory.txt
            ;;
        --exec)
            python map_memory_parse_gcc.py $map_file find --exe $module |tee .$script_name/map_parse_memory.txt
            ;;
        --sort)
            python map_memory_parse_gcc.py $map_file >.$script_name/map_parse_memory.txt
            map_sort
            ;;
        *)
            python map_memory_parse_gcc.py $map_file |tee .$script_name/map_parse_memory.txt
            ;;
    esac
    rm map_memory_parse_gcc.py
    return 0
}
function display-wearable {
    case $arg3 in
        --assign)
            simple_select_config $arg4
            local width=$(cat configs/${config_select%%_*}/$config_select |grep 'STORYBOARD_DISPLAY_WIDTH=' |cut -d '=' -f 2)
            local height=$(cat configs/${config_select%%_*}/$config_select |grep 'STORYBOARD_DISPLAY_HEIGHT=' |cut -d '=' -f 2)
            echo $config_select "(WxH): " $width "*" $height
            ;;
        *)
            for dir in configs/*; do
                if [[ -d "$dir" && "$dir" != "." && "$dir" != ".." ]]; then
                    echo -e "\n** "$dir":"
                    shopt -s nullglob
                    files=("$dir"/"$(basename "$dir")"_*_defconfig)
                    shopt -u nullglob
                    for file in "${files[@]}"; do
                        if [[ -f "$file" ]]; then
                            local width=$(cat $file |grep 'STORYBOARD_DISPLAY_WIDTH=' |cut -d '=' -f 2)
                            local height=$(cat $file |grep 'STORYBOARD_DISPLAY_HEIGHT=' |cut -d '=' -f 2)
                            local underscore_count=$(echo "$file" |tr '_' '\n' |wc -l)
                            [[ $underscore_count -eq 3 && $width && $height ]] && echo $(basename "$file") "(WxH): " $width "*" $height
                        fi
                    done
                fi
            done
            ;;
    esac
    return 0
}
function deduplicate_changelog_process {
    changelog=$1
    local duplicate_changelog="duplicate.changelog"
    [ -f $duplicate_changelog ] && rm $duplicate_changelog
    touch $duplicate_changelog
    mv $duplicate_changelog $CHANGELOG_OUT
    duplicate_changelog=$CHANGELOG_OUT/$duplicate_changelog
    local deduplicate_changelog="deduplicate.changelog"
    [[ -n "$2" ]] && deduplicate_changelog="$2"
    [ -f $deduplicate_changelog ] && rm $deduplicate_changelog
    touch $deduplicate_changelog
    mv $deduplicate_changelog $CHANGELOG_OUT
    deduplicate_changelog=$CHANGELOG_OUT/$deduplicate_changelog
    local changelog_process="process.log"
    [ -f $changelog_process ] && rm $changelog_process
    touch $changelog_process
    mv $changelog_process $CHANGELOG_OUT
    changelog_process=$CHANGELOG_OUT/$changelog_process
    local changelog_check="check.log"
    [ -f $changelog_check ] && rm $changelog_check
    touch $changelog_check
    mv $changelog_check $CHANGELOG_OUT
    changelog_check=$CHANGELOG_OUT/$changelog_check
    local processed_project_count=0
    local history_duplicate_single_repository_linenumbers=0
    local history_deduplicate_single_repository_linenumbers=0
    local process_item_count=$(grep " changed from " $changelog |wc -l)
    local temp_file="$(mktemp)"
    tac $changelog > reverse_$changelog
    while IFS= read -r parent_line; do
        echo $parent_line >> $temp_file
        [[ "$parent_line" == *" changed from "* ]] && {
            processed_project_count=$((processed_project_count + 1))
            cp $temp_file pending_changelog 
            awk 'NF' $temp_file > cache_changelog 
            cp cache_changelog $temp_file
            local origin_single_repository_linenumbers=$(awk 'NF' $temp_file | wc -l)
            local name_single_repository=$(grep " changed from " $temp_file | awk '{print $1}')
            local sub_temp_file="$(mktemp)"
            local temp_duplicate="duplicate.tmp"
            [ $last_cmd = '?' ] && {
                [ -f $temp_duplicate ] && rm $temp_duplicate
                touch $temp_duplicate
                echo -e "\r\n****** Start [$processed_project_count]"  >>$changelog_process
            }
            local processed_count=0
            while IFS= read -r line; do
                processed_count=$((processed_count + 1))
                [ $last_cmd = '?' ] && echo -e "\r\n## Start [$processed_count]"  >>$changelog_process
                local already_processed=$(grep -F "$line" cache_changelog)
                [ -z "$already_processed" ] && {
                    [ $last_cmd = '?' ] && echo -e "\r\nAlready processed: $line"  >> $changelog_process
                    continue
                }
                local jira_describe=$(echo "$line" | grep '[+-]' | awk -F "|" '{print $2}')
                [ -z "$jira_describe" ] && {
                    [ $last_cmd = '?' ] && echo -e "\r\nInvalid Describe -> $line" >> $changelog_process
                    continue
                }
                local jira_commit_hash=$(echo "$line" | grep '[+-]' | awk '{print $2}')
                [ -z "$jira_commit_hash" ] && {
                    [ $last_cmd = '?' ] && echo -e "\r\nInvalid Hash -> $line" >> $changelog_process
                    continue
                }
                sed -i "/\b$jira_commit_hash\b/d" cache_changelog
                [ $last_cmd = '?' ] && {
                    echo -e "\r\n"$jira_commit_hash >> $changelog_process
                    echo "hit sed" >> $changelog_process
                    echo "cache changelog line: "$(awk 'NF' cache_changelog |wc -l) >> $changelog_process
                    echo "describe: "$jira_describe >> $changelog_process
                }
                local jira_describe_prefix=$(echo "$line" | grep '[+-]' | awk -F "|" '{print $1}')
                [ $last_cmd = '?' ] && echo -e "\r\njira  prefix: "$jira_describe_prefix "describe: "$jira_describe  >>$changelog_process
                local jira_commit_status=$(echo "$jira_describe_prefix" | grep '[+-]' | awk '{print $1}')
                local jira_commit_reason=$(echo "$jira_describe_prefix" | grep '[+-]' | awk '{print $3}')
                [ $last_cmd = '?' ] && echo "jira commit  status: "$jira_commit_status "reason: "$jira_commit_reason  >>$changelog_process
                [[ $jira_commit_reason = 'Merge' ]] && {
                    [ $last_cmd = '?' ] && echo -e "\r\n@@Merge  $line"  >>$changelog_process
                    [ -z "$jira_commit_hash" ] && echo "sed error: $line"
                    sed -i "/\b$jira_commit_hash\b/d" pending_changelog
                    echo "$line" >> $duplicate_changelog
                    [ $last_cmd = '?' ] && {
                        local result=$(grep $jira_commit_hash $temp_duplicate | wc -l)
                        [ $result -gt 1 ] && echo -e "\r\nxxxxxx Repeat -> $line"  >>$changelog_process
                        echo "$line" >> $temp_duplicate
                    }
                    continue
                }
                local process_mode=1
                local describe_match_mode=1
                local commit_match_mode=0
                if [ $process_mode -eq 0 ]; then
                    cat cache_changelog > $sub_temp_file
                else
                    jira_describe=${jira_describe%\"}
                    [ $last_cmd = '?' ] && echo "processed describe: "$jira_describe >> $changelog_process
                    grep -wF "$jira_describe" cache_changelog > $sub_temp_file
                    [ $last_cmd = '?' ] && echo "cache changelog line: "$(awk 'NF' cache_changelog |wc -l)"  sub file line: "$(awk 'NF' $sub_temp_file |wc -l) >> $changelog_process
                    [ $last_cmd = '?' ] && cat $sub_temp_file >> $changelog_process
                    local same_linenumbers=$(awk 'NF' $sub_temp_file | wc -l)
                    [ $last_cmd = '?' ] && echo "same line: "$same_linenumbers >> $changelog_process
                    [ $same_linenumbers -eq 0 ] && continue
                fi
                local repository=. 
                [[ $last_cmd = '?' && $(grep $repository $temp_file) ]] && {
                    echo -e "\r\n>>>>>> ($processed_project_count)"  >>$changelog_process
                    echo "$line"  >>$changelog_process
                    echo -e "\r\n======"  >>$changelog_process
                    cat $sub_temp_file  >>$changelog_process
                    echo -e "\r\n<<<<<<"  >>$changelog_process
                    cat pending_changelog  >>$changelog_process
                    echo -e "\r\n------"  >>$changelog_process
                }
                [ $last_cmd = '?' ] && echo -e "\r\n## Start(sub)"  >>$changelog_process
                local sub_cycle=0
                while IFS= read -r sub_line <&3; do
                    sub_cycle=$((sub_cycle + 1))
                    [[ $last_cmd = '?' && $(grep $repository $temp_file) ]] && {
                        echo -e "\r\n>>>>>> Sub($sub_cycle)"  >>$changelog_process
                        echo "target: $line"  >>$changelog_process
                        echo "sub: $sub_line"  >>$changelog_process
                        echo -e "\r\n======"  >>$changelog_process
                        cat $temp_duplicate  >>$changelog_process
                        echo -e "\r\n<<<<<<"  >>$changelog_process
                    }
                    local sub_jira_describe=$(echo "$sub_line" | grep '[+-]' | awk -F "|" '{print $2}')
                    local sub_jira_describe_prefix=$(echo "$sub_line" | grep '[+-]' | awk -F "|" '{print $1}')
                    [ $last_cmd = '?' ] && echo "sub jira  prefix: "$sub_jira_describe_prefix "describe: "$sub_jira_describe  >>$changelog_process
                    local sub_jira_commit_status=$(echo "$sub_jira_describe_prefix" | grep '[+-]' | awk '{print $1}')
                    local sub_jira_commit_hash=$(echo "$sub_jira_describe_prefix" | grep '[+-]' | awk '{print $2}')
                    local sub_jira_commit_reason=$(echo "$sub_jira_describe_prefix" | grep '[+-]' | awk '{print $3}')
                    [ $last_cmd = '?' ] && echo "jira commit  status: "$sub_jira_commit_status "reason: "$sub_jira_commit_reason  >>$changelog_process
                    [[ $sub_jira_commit_reason = 'Merge' ]] && {
                        [ $last_cmd = '?' ] && echo -e "\r\n@@Merge(sub)  $sub_line"  >>$changelog_process
                        [[ ! $sub_jira_commit_hash ]] && echo "sed error: $sub_line"
                        sed -i "/\b$sub_jira_commit_hash\b/d" pending_changelog
                        sed -i "/\b$sub_jira_commit_hash\b/d" cache_changelog
                        echo "$sub_line" >> $duplicate_changelog
                        [ $last_cmd = '?' ] && {
                            local result=$(grep $sub_jira_commit_hash $temp_duplicate | wc -l)
                            [ $result -gt 1 ] && echo -e "\r\nxxxxxx Repeat(sub) -> $sub_line"  >>$changelog_process
                            echo "$sub_line" >> $temp_duplicate
                        }
                        continue
                    }
                    sub_jira_describe=${sub_jira_describe%\"}
                    [ $last_cmd = '?' ] && echo "processed describe(sub): "$sub_jira_describe >>$changelog_process
                    [[ ($describe_match_mode = 1 && "$jira_describe" != "$sub_jira_describe") || \
                       ($describe_match_mode = 0 && "$jira_describe" != *"$sub_jira_describe"* && "$sub_jira_describe" != *"$jira_describe"*) ]] && {
                        [ $last_cmd = '?' ] && {
                            echo -e "\r\n!Warning: jira describe not match" >> $changelog_process
                            echo "describe: "$jira_describe  >>$changelog_process
                            echo "describe(sub): "$sub_jira_describe  >>$changelog_process
                        }
                        continue
                    }
                    [[ "$jira_commit_status" = "$sub_jira_commit_status" ]] && {
                        [[ $jira_commit_reason = 'Revert' || $sub_jira_commit_reason = 'Revert' ]] && {
                            [ $commit_match_mode = 1 ] && {
                                local revert_commit_hash=$(ssh -n -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set commit:$jira_commit_hash |grep -w "This reverts commit" |awk '{print $4}')
                                local sub_revert_commit_hash=$(ssh -n -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set commit:$sub_jira_commit_hash |grep -w "This reverts commit" |awk '{print $4}')
                                [ $last_cmd = '?' ] && {
                                    echo -e "\r\n@Revert process"  >>$changelog_process
                                    echo "Target commit  $jira_commit_hash"  >>$changelog_process
                                    echo "Reverts commit  $revert_commit_hash"  >>$changelog_process
                                    echo "Reverts commit(sub)  $sub_revert_commit_hash"  >>$changelog_process
                                }
                                [[ "$sub_revert_commit_hash" != *"$jira_commit_hash"* && "$revert_commit_hash" != *"$sub_jira_commit_hash"* ]] && {
                                    [ $last_cmd = '?' ] && echo -e "\r\n!Warning: Revert not match"  >>$changelog_process
                                    continue
                                }
                            }
                            [ $last_cmd = '?' ] && echo -e "\r\n@@Revert  $line"  >>$changelog_process && echo $sub_line  >>$changelog_process
                            sed -i "/\b$jira_commit_hash\b/d" pending_changelog
                            sed -i "/\b$sub_jira_commit_hash\b/d" pending_changelog
                            sed -i "/\b$sub_jira_commit_hash\b/d" cache_changelog
                            [ $last_cmd = '?' ] && {
                                local result=$(grep $jira_commit_hash $temp_duplicate | wc -l)
                                [ $result -gt 1 ] && echo -e "\r\nxxxxxx Repeat -> $line"  >>$changelog_process
                                echo "$line" >> $temp_duplicate
                            }
                            echo "$line" >> $duplicate_changelog
                            [ $last_cmd = '?' ] && {
                                local result=$(grep $sub_jira_commit_hash $temp_duplicate | wc -l)
                                [ $result -gt 1 ] && echo -e "\r\nxxxxxx Repeat(sub) -> $sub_line"  >>$changelog_process
                                echo "$sub_line" >> $temp_duplicate
                            }
                            echo "$sub_line" >> $duplicate_changelog
                            break
                        }
                    }
                    [[ "$jira_commit_status" != "$sub_jira_commit_status" ]] && {
                        [[ $jira_commit_reason = $sub_jira_commit_reason ]] && {
                            [ $commit_match_mode = 1 ] && {
                                readarray -t temp_describe < <(ssh -n -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set commit:$jira_commit_hash |grep -w "subject:" |awk -F "|" '{print $2}')
                                readarray -t temp_change < <(ssh -n -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set commit:$jira_commit_hash |grep -w "change" |awk '{print $2}')
                                [ $last_cmd = '?' ] && echo "temp_describe: ${temp_describe[*]}"  >>$changelog_process
                                local index=0
                                [ ${#temp_describe[*]} -lt 1 ] && {
                                    [ $last_cmd = '?' ] && echo -e "\r\n!!Error: not find describe"  >>$changelog_process
                                    continue
                                }
                                [ $last_cmd = '?' ] && echo "target describe: $jira_describe"  >>$changelog_process
                                for describe in "${temp_describe[@]}"; do
                                    [[ "$describe" = "$jira_describe" ]] && break
                                    ((index++))
                                done
                                [ $index -eq ${#temp_describe[@]} ] && {
                                    [ $last_cmd = '?' ] && echo -e "\r\n!!Error: not find same describe"  >>$changelog_process && echo ${temp_describe[@]}  >>$changelog_process
                                    continue
                                }
                                [ $last_cmd = '?' ] && echo "temp_change: ${temp_change[*]}"  >>$changelog_process
                                local changeid=${temp_change[$index]}
                                [ $last_cmd = '?' ] && echo "changeid: $changeid"  >>$changelog_process
                                readarray -t temp_describe < <(ssh -n -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set commit:$sub_jira_commit_hash |grep -w "subject:" |awk -F "|" '{print $2}')
                                readarray -t temp_change < <(ssh -n -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set commit:$sub_jira_commit_hash |grep -w "change" |awk '{print $2}')
                                [ $last_cmd = '?' ] && echo "temp_describe(sub): ${temp_describe[*]}"  >>$changelog_process
                                [ ${#temp_describe[*]} -lt 1 ] && {
                                    [ $last_cmd = '?' ] && echo -e "\r\n!!Error: not find describe(sub)"  >>$changelog_process
                                    continue
                                }
                                [ $last_cmd = '?' ] && echo "target describe(sub): $sub_jira_describe"  >>$changelog_process
                                local index=0
                                for describe in "${temp_describe[@]}"; do
                                    [[ "$describe" = "$sub_jira_describe" ]] && break
                                    ((index++))
                                done
                                [ $index -eq ${#temp_describe[@]} ] && {
                                    [ $last_cmd = '?' ] && echo -e "\r\n!!Error: not find same describe(sub)"  >>$changelog_process && echo ${temp_describe[@]}  >>$changelog_process
                                    continue
                                }
                                [ $last_cmd = '?' ] && echo "change: ${temp_change[*]}"  >>$changelog_process
                                local sub_changeid=${temp_change[$index]}
                                [ $last_cmd = '?' ] && echo "sub_changeid: $sub_changeid"  >>$changelog_process
                                [ $last_cmd = '?' ] && {
                                    echo -e "\r\n@Cherry-pick process"  >>$changelog_process
                                    echo "Target change-id  $changeid"  >>$changelog_process
                                    echo "Cherry-pick change-id  $sub_changeid"  >>$changelog_process
                                }
                                [[ "$changeid" != "$sub_changeid" ]] && {
                                    [ $last_cmd = '?' ] && echo  -e "\r\n!Warning: Cherry-pick not match"  >>$changelog_process
                                    continue
                                }
                            }
                            [ $last_cmd = '?' ] && echo -e "\r\n@@[+-]  $line"  >>$changelog_process && echo "$sub_line"  >>$changelog_process
                            [[ ! $jira_commit_hash ]] && echo "sed error: $line"
                            sed -i "/\b$jira_commit_hash\b/d" pending_changelog
                            [[ ! $sub_jira_commit_hash ]] && echo "sub sed error: $sub_line"
                            sed -i "/\b$sub_jira_commit_hash\b/d" pending_changelog
                            sed -i "/\b$sub_jira_commit_hash\b/d" cache_changelog
                            [ $last_cmd = '?' ] && {
                                local result=$(grep $jira_commit_hash $temp_duplicate | wc -l)
                                [ $result -gt 1 ] && echo -e "\r\nxxxxxx Repeat -> $line"  >>$changelog_process
                                echo "$line" >> $temp_duplicate
                            }
                            echo "$line" >> $duplicate_changelog
                            [ $last_cmd = '?' ] && {
                                local result=$(grep $sub_jira_commit_hash $temp_duplicate | wc -l)
                                [ $result -gt 1 ] && echo -e "\r\nxxxxxx Repeat(sub)-> $sub_line"  >>$changelog_process
                                echo "$sub_line" >> $temp_duplicate
                            }
                            echo "$sub_line" >> $duplicate_changelog
                            break
                        }
                    }
                done 3< $sub_temp_file
            done < $temp_file
            cat pending_changelog >> $deduplicate_changelog
            echo -e "$parent_line\r\n" >> $duplicate_changelog
            [[ ${EXEC_PARAMS[@]} =~ 'check' ]] && {
                local temp_duplicate_linenumbers=$(awk 'NF' $duplicate_changelog | wc -l)
                local duplicate_single_repository_linenumbers=$((temp_duplicate_linenumbers - history_duplicate_single_repository_linenumbers))
                local temp_deduplicate_linenumbers=$(awk 'NF' $deduplicate_changelog | wc -l)
                local deduplicate_single_repository_linenumbers=$((temp_deduplicate_linenumbers - history_deduplicate_single_repository_linenumbers))
                local process_single_repository_linenumbers=$((duplicate_single_repository_linenumbers + deduplicate_single_repository_linenumbers))
                process_single_repository_linenumbers=$((process_single_repository_linenumbers - 1))
                local process_result="√"
                [[ $origin_single_repository_linenumbers != $process_single_repository_linenumbers ]] && process_result="×"
                echo "[$process_result] project($processed_project_count) " $name_single_repository": " $((origin_single_repository_linenumbers - 1))" " $((deduplicate_single_repository_linenumbers - 1))" "$((duplicate_single_repository_linenumbers - 1)) >> $changelog_check
                history_duplicate_single_repository_linenumbers=$temp_duplicate_linenumbers
                history_deduplicate_single_repository_linenumbers=$temp_deduplicate_linenumbers
            }
            > $temp_file 
            rm $sub_temp_file
            echo $((processed_project_count * 100 / process_item_count)) >$spin_percent_file
        }
    done < reverse_$changelog
    tac $duplicate_changelog > pending_changelog
    cp pending_changelog $duplicate_changelog
    tac $deduplicate_changelog > pending_changelog
    cp pending_changelog $deduplicate_changelog
    [[ ${EXEC_PARAMS[@]} =~ 'check' ]] && {
        echo "status    item    project    origin  deduplicate  duplicate" >> $changelog_check
        local dup_number=$(awk 'NF' $duplicate_changelog | wc -l)
        local dedup_number=$(awk 'NF' $deduplicate_changelog | wc -l)
        local changelog_number=$(awk 'NF' $changelog | wc -l)
        local changelog_other_number=$(awk '/added projects/,/changed projects/ { if (NF) count++ } END { print count }' $changelog)
        local origin_count=$((changelog_number - changelog_other_number))
        local dup_item_count=$(grep " changed from " $duplicate_changelog |wc -l)
        local processed_count=$((dup_number - dup_item_count + dedup_number))
        echo -e "\r\norigin changelog item count: "$process_item_count "line number: $changelog_number - $changelog_other_number = "$origin_count >> $changelog_check
        echo "processed line number: dup_number($dup_number) - dup_item_count($dup_item_count) + dedup_number($dedup_number) = "$processed_count >> $changelog_check
        [ $origin_count = $processed_count ] && echo "Processed Progress: OK" |tee -a $changelog_check || echo "Processed Progress: Error" |tee -a $changelog_check
        [ $process_mode -eq 0 ] && mode0="Match Mode: LineByLine" || mode0="Match Mode: FilterString"
        [ $describe_match_mode -eq 0 ] && mode1="KeyWord" || mode1="WholeWord"
        [ $commit_match_mode -eq 0 ] && mode2="Rules" || mode2="Accurate"
        echo "$mode0  $mode1  $mode2" >> $changelog_check
        echo "## generate by "$GERRIT_USER "  @"$(date) >> $changelog_check
        tac $changelog_check > pending_changelog
        cp pending_changelog $changelog_check
    }
    rm $temp_file
    rm cache_changelog
    rm pending_changelog
    rm reverse_$changelog
    [ -f $temp_duplicate ] && rm $temp_duplicate
    return 0
}
module_hit_table=("sport")
function changelog_find_owner {
    local counter=1
    local sub_counter=1
    local module_hit=""
    local assign_name=""
    local commit_hash_repeat="commit_hash_repeat.txt"
    local changelog_error="changelog.error"
    local changelog_out="_out.txt"
    local output_type="txt"
    read -p "input file: " changelog
    [ ! $changelog ] && changelog="changelog.txt"
    [ ! -f $changelog ] && {
        echo "!! file $changelog not exist"
        return -1
    }
    local processed_task_count=0
    local task_count=$(grep " changed from " $changelog |wc -l)
    start_spin
    [[ ! -d $CHANGELOG_OUT ]] && mkdir $CHANGELOG_OUT
    [[ ${EXEC_PARAMS[@]} =~ '--deduplicate' ]] && {
        local deduplicate_changelog="deduplicate.changelog"
        deduplicate_changelog_process $changelog $deduplicate_changelog
        changelog=$CHANGELOG_OUT/$deduplicate_changelog
        [[ $last_cmd = 'only' ]] && return 0
        echo -e "\nDeduplicate changelog complete!"
    }
    echo -e "\nFormatting..."
    [[ ${EXEC_PARAMS[@]} =~ '--out-format' ]] && {
        get_option_index_and_value --out-format
        if [[ "$OPTION_VALUE" == 'md' ]]; then
            changelog_out="_out.md"
            output_type="md"
        elif [[ "$OPTION_VALUE" == 'table' ]]; then
            changelog_out="_out.md"
            output_type="table"
        elif [[ "$OPTION_VALUE" == 'csv' ]]; then
            changelog_out="_out.csv"
            output_type="csv"
        elif [[ "$OPTION_VALUE" == 'html' ]]; then
            changelog_out="_out.html"
            output_type="html"
        fi
    }
    [[ ${EXEC_PARAMS[@]} =~ '--assign' ]] && {
        get_option_index_and_value --assign
        if [ -z "${OPTION_VALUE:-}" ];then
            changelog_out="assign_${changelog_out}"
        else
            assign_name="$OPTION_VALUE"
            changelog_out="${assign_name}_${changelog_out}"
        fi
    }
    [[ ${EXEC_PARAMS[@]} =~ '--module' ]] && {
        module_hit="ALL"
        get_option_index_and_value --module
        if [ -n "$OPTION_VALUE" ];then
            for module in "${module_hit_table[@]}"; do
                if [[ "$OPTION_VALUE" == "$module" ]]; then
                    module_hit=$OPTION_VALUE
                fi
            done
        fi
        echo -e "\nmodule_hit: $module_hit"
        [ -z "$module_hit" ] && echo -e "\e[7;33mPlease check module name\e[0m"
        changelog_out=${module_hit}_$changelog_out
    }
    [[ ${EXEC_PARAMS[@]} =~ '--type' ]] && {
        get_option_index_and_value --type
        filter_type=$OPTION_VALUE
    }
    changelog_out="${changelog_out}"
    [ -f $changelog_out ] && rm $changelog_out
    touch $changelog_out
    [ -f $changelog_error ] && rm $changelog_error
    touch $changelog_error
    [ -f $commit_hash_repeat ] && rm $commit_hash_repeat
    touch $commit_hash_repeat
    local changelog_prefix=`date +"%y%m%d%H%M"`
    changelog_prefix="changelog_out_"$changelog_prefix
    mkdir $changelog_prefix
    mv $changelog_out $changelog_prefix
    changelog_out=$changelog_prefix/$changelog_out
    mv $changelog_error $changelog_prefix
    changelog_error=$changelog_prefix/$changelog_error
    mv $commit_hash_repeat $changelog_prefix
    commit_hash_repeat=$changelog_prefix/$commit_hash_repeat
    local temp_file="$(mktemp)"
    local file_header="# Automatically create @ $(date)\n"
    file_header+="# [rowCount]: There are too many gerrit information submitted\n"
    file_header+="# [gerrit-url]: The commit-id cannot find the corresponding submit link\n"
    echo -e $file_header >$changelog_error
    file_header="# Automatically create @ $(date)\n"
    file_header+="# [gerrit-url]: The submitted link corresponding to the commit-id value is not unique\n"
    echo -e $file_header >$commit_hash_repeat
    if [[ "$output_type" == "table" ]]; then
        echo "| Where | Index | Owner | Jira | Gerrit |" >$changelog_out
        echo "| ----- | ----- | ----- | ---- | ------ |" >>$changelog_out
    elif [[ "$output_type" == "csv" ]]; then
        echo "Where,Index,Owner,Commit,Jira" >$changelog_out
    elif [[ "$output_type" == "html" ]]; then
        echo -e "<style>\n  table {\n    border-collapse: collapse;\n    width: 100%;\n  }\n  th, td {\n    text-align: left;\n\
    padding: 8px;\n    border: 1px solid #ddd;\n    white-space: nowrap;\n  }\n</style>\n" >$changelog_out
        if [ -n "${filter_type:-}" ]; then
            echo -e "<div class="table-title">@$(date) by $GERRIT_USER    #处理类型：${filter_type}</div>" >>$changelog_out
        else
            echo -e "<div class="table-title">@$(date) by $GERRIT_USER</div>" >>$changelog_out
        fi
        echo -e "<table>\n  <tr>\n    <th>Index</th>\n    <th>Owner</th>\n    <th>Jira</th>\n    <th>Gerrit</th>\n    <th>Where</th>\n  </tr>\n" >>$changelog_out
    fi
    local hit_linenum=0
    local line_number=0
    local find_done=0
    while IFS= read -r line <&3; do
        ((line_number++))
        [ -z "$line" ] && continue
        [[ "$line" == *" changed from "* ]] && {
            processed_task_count=$((processed_task_count + 1))
            echo $((processed_task_count * 100 / task_count)) >$spin_percent_file
        }
        local persent=$([ -f $spin_percent_file ] && cat $spin_percent_file)
        pulse_diagnosis 101 $persent "$$persent  line: $line_number"
        [[ $module_hit = 'sport' ]] && {
            if [[ "$line" == *" changed from "* ]]; then
                find_done=0
                for module in "${sport_modules[@]}"; do
                    if [[ "$line" == *"$module"* ]]; then
                        find_done=1
                        break
                    fi
                done
                [[ $find_done -eq 0 ]] && continue
            fi
        } || find_done=1
        [[ "$line" == *" changed from "* ]] && {
            local project_name=$(echo "$line" |awk '{print $1}')
            if [[ "$output_type" == "table" ]]; then
                project_name_out="| Project: $project_name |"
            elif [[ "$output_type" == "csv" ]]; then
                project_name_out="Project: $project_name,"
            elif [[ "$output_type" == "html" ]]; then
                project_name_out="  <tr>\n    <td colspan="5">Project: ${project_name}</td>\n  </tr>\n"
            elif [[ "$output_type" == "md" ]]; then
                project_name_out="**Project: ${project_name}**"
            else
                project_name_out="Project: $project_name"
            fi
            minus_node=$(echo "$line" |awk -F 'changed from' '{print $2}' |awk -F 'to' '{print $1}' |xargs)
            plus_node=$(echo "$line" |awk -F 'changed from' '{print $2}' |awk -F 'to' '{print $2}' |xargs)
            continue
        }
        if [ -n "${filter_type:-}" ]; then
            local commit_type=$(echo "$line" | grep -E '\[\+|\[-\]' |awk '{print $3}')
            log_assert $? "$line"
            pulse_diagnosis $hit_linenum $line_number "hit line-number"
            [[ "$commit_type" != "$filter_type" ]] && continue
        fi
        [ $find_done = 1 ] && {
            local commit_hash=$(echo "$line" | grep -E '\[\+|\[-\]' > /dev/null && echo "$line" | awk '{print $2}')
            log_assert $? "$line"
            pulse_diagnosis $hit_linenum $line_number "hit line-number"
            [[ -z "$commit_hash" ]] && continue
            local commit_sign=$(echo "$line" |awk -F '[\\[\\]]' '{print $2}')
            if [[ $commit_sign == '-' ]]; then
                commit_where="$minus_node"
            elif [[ $commit_sign == '+' ]]; then
                commit_where="$plus_node"
            else
                commit_where="unKnown"
            fi
            ((counter++))
            ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set commit:$commit_hash >$temp_file
            local result_count=$(grep -w "^rowCount:" $temp_file |wc -l)
            log_assert $? "$line"
            pulse_diagnosis $hit_linenum $line_number "hit line-number"
            [ $result_count -gt 1 ] && echo "[rowCount]  $counter> $rowCount" >>$changelog_error && continue
            local link_count=$(grep -w "^rowCount:" $temp_file | cut -d ':' -f2)
            log_assert $? "$line"
            pulse_diagnosis $hit_linenum $line_number "hit line-number"
            [[ $link_count -gt 1 ]] && {
                echo $commit_hash >>$commit_hash_repeat
                local commit_comment=$(echo "$line" | grep '[+-]' | awk -F "|" '{print $2}')
                log_assert $? "$line"
                pulse_diagnosis $hit_linenum $line_number "hit line-number"
                local escaped_commit_comment="$(escape_for_grep "$commit_comment")"
                local change_number=$(grep -E -B 1 "subject: .*$escaped_commit_comment" $temp_file |grep -w 'number:' |cut -d ':' -f2)
                diagnose_cmd "grep -E -B 1 \"subject: .*$escaped_commit_comment\" $temp_file |grep -w 'number:'"
                log_assert $? "$line"
                pulse_diagnosis $hit_linenum $line_number "hit line-number"
                ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query --current-patch-set change:$change_number >$temp_file
            }
            local owner_name=$(grep -A 1 'owner:' $temp_file | grep 'name:' | cut -d ':' -f2)
            log_assert $? "$line"
            pulse_diagnosis $hit_linenum $line_number "hit line-number"
            local owner_describe="  【owner】 $owner_name"
            [[ ${EXEC_PARAMS[@]} =~ '--assign' ]] && {
                [[ ! "$owner_name" =~ "$assign_name" ]] && continue
            }
            [[ -n $project_name_out ]] && echo -e "$project_name_out" >>$changelog_out
            unset project_name_out
            if [[ "$output_type" == "md" || "$output_type" == "table" || "$output_type" == "html" ]]; then
                local gerrit_url=$(grep 'url:' $temp_file | cut -d ' ' -f4)
                log_assert $? "$line"
                pulse_diagnosis $hit_linenum $line_number "hit line-number"
                [ ! $gerrit_url ] && echo "[gerrit-url]  $counter> $commit_hash" >>$changelog_error && continue
                jira_describe=$(grep 'subject:' $temp_file | cut -d '|' -f2)
                log_assert $? "$line"
                pulse_diagnosis $hit_linenum $line_number "hit line-number"
                local jira_number=$(echo $jira_describe | cut -d '>' -f1 | xargs)
                [ ! $jira_number ] && {
                    jira_number=$(grep 'subject:' $temp_file | cut -d ' ' -f4)
                    log_assert $? "$line"
                    pulse_diagnosis $hit_linenum $line_number "hit line-number"
                }
                local jira_text=$(echo $jira_describe | cut -d '>' -f2 | xargs -0)
                [ $last_cmd = '-v' ] && echo "$counter> [$jira_number] $jira_text  $owner_name"
                if [[ "$output_type" == "md" ]]; then
                    echo "* ($sub_counter)  $owner_name [$jira_number](https://jira.huami.com/browse/$jira_number) > [$jira_text]($gerrit_url)" >>$changelog_out
                elif [[ "$output_type" == "table" ]]; then
                    echo "| $commit_where | $sub_counter | $owner_name | [$jira_number](https://jira.huami.com/browse/$jira_number) | [$jira_text]($gerrit_url) |" >>$changelog_out
                elif [[ "$output_type" == "html" ]]; then
                    local temp_content="  <tr>\n    <th>${sub_counter}</th>"
                    temp_content+="\n    <th>${owner_name}</th>"
                    temp_content+="\n    <th><a href="https://jira.huami.com/browse/$jira_number" target="_blank">${jira_number}</a></th>"
                    temp_content+="\n    <th><a href="$gerrit_url" target="_blank">${jira_text}</a></th>" 
                    temp_content+="\n    <th>${commit_where}</th>"
                    temp_content+="\n  </tr>\n"
                    echo -e $temp_content >>$changelog_out
                fi
                ((sub_counter++))
            elif [[ "$output_type" == "csv" ]]; then
                local commit_hash=$(echo "$line" |awk '{print $2}')
                local jira1=$(echo "$line" |awk -F '|' '{print $1}' |awk '{print $3}')
                local jira2=$(echo "$line" |awk -F '|' '{print $2}')
                local jira_text="$jira1 | $jira2"
                echo "$commit_where,$sub_counter,$owner_name,$commit_hash,$jira_text" >>$changelog_out
                ((sub_counter++))
            else
                [[ $last_cmd = '-v' ]] && {
                    local commit_type=$(echo "$line" | grep -E '\[\+|\[-\]' | awk '{print $3}')
                    log_assert $? "$line"
                    pulse_diagnosis $hit_linenum $line_number "hit line-number"
                    echo $counter">: "$commit_hash": "$owner_describe": ["$commit_type"]"
                }
                echo "$line" "$owner_describe" >> $changelog_out
            fi
        }
    done 3< $changelog
    if [[ "$output_type" == "html" ]]; then
        echo "</table>" >>$changelog_out
    fi
    mv $changelog_prefix $CHANGELOG_OUT
    echo -e "\nout: $CHANGELOG_OUT/$changelog_out"
    [ -f $temp_file ] && rm $temp_file
    return 0
}
commit_count_from_gerrit() {
    local name=self
    if hit_option '--name'; then
        parse_options --name
        if ! check_last_cmd; then
            return 1
        fi
        name="$OPTION_VALUE"
    fi
    local state=""
    local query_expr="owner:\"$name\""
    if hit_option '--status'; then
        parse_options --status
        if ! check_last_cmd; then
            return 1
        fi
        state="$OPTION_VALUE"
        query_expr="$query_expr status:\"$state\""
    fi
    local start=0
    local commit_cnt=0
    local temp_file="$(mktemp)"
    local temp_file_dedup="$(mktemp)"
    local temp_file_number="$(mktemp)"
    echo_c -c "All: Press Enter. N-days: Nd. N-weeks: Nw. N-month: Nm."
    read -p "Enter the number of days you want to query: " days
    if is_number ${days%?}; then
        after_time=$(convert_iso8601_date $days)
        query_expr="$query_expr after:\"$after_time\""
    fi
    [[ $last_cmd = '?' ]] && echo_c -y "$query_expr"
    echo "counting commit..."
    while true; do
        ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query $query_expr --start $start >$temp_file
        local tail_info=$(cat $temp_file |tail -n 5)
        local user_verify=$(echo $tail_info |awk '{print $2}' |xargs)
        [[ $user_verify = 'error' ]] && echo "!!No such person found" && return -1
        local temp_cnt=$(echo $tail_info |awk '{print $4}' |xargs)
        if hit_option '--dedup'; then
            grep -e number: -e cherryPickOfChange $temp_file >$temp_file_dedup
            awk '
            {
                gsub(/^[[:space:]]+/, "");
                gsub(/[[:space:]]+$/, "");
            }
            NR == 1 {
                prev = $0
                is_prev_number = ($0 ~ /^number:/)
                next
            }
            {
                current = $0
                is_current_number = ($0 ~ /^number:/)
                is_current_cherry = ($0 ~ /^cherryPickOfChange:/)
                if ((is_prev_number && is_current_cherry) || (is_current_number && is_prev_cherry)) {
                    prev = ""
                } else if (prev != "") {
                    print prev
                }
                prev = current
                is_prev_number = ($0 ~ /^number:/)
                is_prev_cherry = ($0 ~ /^cherryPickOfChange:/)
            }
            END {
                if (prev != "" && !is_current_cherry) print prev
            }' $temp_file_dedup >>$temp_file_number
        else
            grep number: $temp_file >>$temp_file_number
        fi
        commit_cnt=$((commit_cnt + temp_cnt))
        local more=$(echo $tail_info |awk '{print $8}' |xargs)
        [[ $more = 'false' ]] && break
        start=$((start + 500))
    done
    local valid_commit_cnt=$(wc -l <$temp_file_number)
    rm $temp_file
    rm $temp_file_dedup
    [[ $valid_commit_cnt -eq 0 ]] && {
        rm $temp_file_number
        echo_c -y "!!Nothing"
        return 0
    }
    if [[ $state = *-* ]]; then
        local last_create_date=$(ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query $query_expr |grep -m 1 'createdOn:' |awk -F 'createdOn:' '{print $2}' |xargs)
        local last_update_date=$(ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query $query_expr |grep -m 1 'lastUpdated:' |awk -F 'createdOn:' '{print $2}' |xargs)
    else
        local last_create_date=$(ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query $query_expr limit:1 |awk -F 'createdOn:' '{print $2}' |xargs)
        local last_update_date=$(ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query $query_expr limit:1 |awk -F 'lastUpdated:' '{print $2}' |xargs)
    fi
    local first_create_date=$(ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query $query_expr --start $((commit_cnt - 1)) limit:1 |awk -F 'createdOn:' '{print $2}' |xargs)
    local first_update_date=$(ssh -p 29418 $GERRIT_USER@$GERRIT_HOST gerrit query $query_expr --start $((commit_cnt - 1)) limit:1 |awk -F 'lastUpdated:' '{print $2}' |xargs)
    echo "$name: $valid_commit_cnt / $commit_cnt"
    echo "first date: "$first_create_date " ~ "$first_update_date
    echo "last date: "$last_create_date " ~ "$last_update_date
    echo "counting code..."
    start_spin
    local cnt=0
    local sum_cnt=$(cat $temp_file_number |wc -l)
    local temp_file_commit="$(mktemp)"
    local temp_file_sort="$(mktemp)"
    while read -r line; do
        (( cnt++ ))
        echo $((cnt * 100 / sum_cnt)) >$spin_percent_file
        local change_number=$(echo $line |awk '{print $2}')
        ssh -n -p 29418 "$GERRIT_USER@$GERRIT_HOST" gerrit query --current-patch-set "change:$change_number" | \
        tee \
            >(awk '/sizeInsertions:/ {print $0}' >>$temp_file_commit) \
            >(awk '/sizeDeletions:/ {print $0}' >>$temp_file_commit) \
            >(awk -v cnum="$change_number" '/sizeInsertions:/ {print cnum " " $0}' >>$temp_file_sort) \
            > /dev/null 
    done <$temp_file_number
    echo "rowCount: "$cnt >>$temp_file_commit
    count_code_line_from_gerrit $temp_file_commit
    awk '/sizeInsertions:/ {print $1, $3}' "$temp_file_sort" | \
    sort -k2,2nr | \
    head -n 9 |\
    awk '{printf "%d. %s\n", NR, $0}'
    rm $temp_file_number
    rm $temp_file_commit
    rm $temp_file_sort
}
env_cfg() {
    local name=self
    if hit_option '--repo'; then
        rm -rf .repo/repo
        git clone https://gerrit.googlesource.com/git-repo .repo/repo
    fi
}
function dit-tools {
    option_check $arg2
    sudo rm -rf /usr/bin/python
    sudo ln -s /usr/bin/python3.8 /usr/bin/python
    scripts_path="/mnt/f/skull/boyer/dit"
    case $arg2 in
        map)
            map
            ;;
        display)
            display-wearable
            ;;
        crc)
            cp $scripts_path/gen_crc32.py .
            python gen_crc32.py $arg3
            rm gen_crc32.py
            ;;
        owner)
            changelog_find_owner
            ;;
        commit)
            commit_count_from_gerrit
            ;;
        env)
            env_cfg
            ;;
        *)
            echo -e "\n!!Please check the option parameters"
            ;;
    esac
    return $?
}
function dit-cfg {
    option_check $arg2
    local reval=0
    case $arg2 in
        --fw-dir)
            dircfg $arg3 $arg4
            reval=$?
            ;;
        --mk-product)
            local mk_files=("$MAKE_MENU" "$MAKE_SIM_MENU")
            for file in "${mk_files[@]}"
            do
                if hit_option '-d'; then
                    rm -f $file
                fi
                if hit_option '-e' && [ ! -f "$file" ]; then
                    >$file
                fi
                [ ! -f $file ] && {
                    for string in "${enum_config[@]}"
                    do
                        entry="$string 1"
                        echo -e "$entry" >> "$file"
                    done
                }
            done
            ;;
        --signature)
            [[ $last_cmd = '-s' ]] && {
                cat $DIT_PATH/signature.path
                return 0
            }
            echo "now path: "$(cat $DIT_PATH/signature.path)
            read -p "Enter your signature path: " signature_path
            [[ ! -d $signature_path ]] && {
                read -p "The path does not exist, do you need to create it? Y/N: " answer
                [[ $answer == 'Y' ]] && {
                    mkdir $signature_path
                    echo "Please move the file sign.pem to the path : " $signature_path
                } || {
                    unset signature_path
                    return 1
                }
            }
            echo $signature_path"/sign.pem" >$DIT_PATH/signature.path
            ;;
        --history)
            echo -e "\nWrite order of operation history file:\n0> LIFO\n1> FIFO"
            read -p ": " select
            [[ $select =~ ^[0-9]+$ ]] && {
                if [ $select -eq 0 ]; then
                    echo "LIFO" >$DOT_DIT/history.cfg
                elif [ $select -eq 1 ]; then
                    echo "LIFO" >$DOT_DIT/history.cfg
                else
                    echo "!Exceeded the limit"
                    return 1
                fi
            }
            echo "!Input is illegal"
            return 1
            ;;
        --commit-editor)
            prompt="
 * config commit editor:
 1> vim
 2> multi line on console
 3> multi line on console (unfriendly to chinese )
 : "
            read -p "$prompt" editor
            sudo bash -c "echo $editor >$CFG_IN_DIR/commit.edit"
            ;;
        *)
            echo -e "\n!!Please check the option parameters: [$1]"
            ;;
    esac
    return $reval
}
function dit-code {
    [[ ! $arg2 || ! -d $arg2 ]] && echo "Please check the code directory!" && return 1
    [ $arg3 ] && {
        [ ! -d $arg3 ] && {
            echo "The entered storage path does not exist!"
            read -p "Create a directory Y/N?: " answer
            [ $answer = 'Y' ] && mkdir -p $arg3
        }
        [ -d $arg3 ] && code_destination_path=$arg3
    }
    local read=$(date +"%m%d")
    [ -d ${arg2}_$read ] && rm -rf ${arg2}_$read
    mkdir ${arg2}_$read
code_dir=(
3rdparty
application
components
core
deprecated
drivers
framework
hmalgo
packages
platform
ui
uiframework
)
    echo "working..."
    for ((index=0; index<${#code_dir[@]}; index++))
    do
        rsync -r --info=progress2 $arg2/${code_dir[$index]} ${arg2}_$read
    done
    echo "Clipping..."
    find ${arg2}_$read -name .git -type d |xargs rm -rf
    find ${arg2}_$read -name prototype -type d |xargs rm -rf
    find ${arg2}_$read/ui -name js_* |xargs rm -rf
    find ${arg2}_$read/ui -name *.png |xargs rm -rf
    find ${arg2}_$read -name *.a -o -name *.bin -o -name *.html -o -name *.txt -o -name *.js |xargs rm -rf
    tar czvf ${arg2}_$read.tar.gz ./${arg2}_$read
    rm -rf ${arg2}_$read
    [ ! $code_destination_path ] && {
        read -p "Enter code migration directory(Press Enter to skip): " move_dir
        [ ! $move_dir ] && {
            parse_dirctory
            move_dir=$read_dir
        }
        [ ! -d $move_dir ] && {
            echo "You entered storage path does not exist!"
            read -p "Create a directory Y/N?: " answer
            [ $answer = 'Y' ] && mkdir -p $move_dir
            while :
            do
                [ ! -d $move_dir ] && read -p "enter again: " code_dir
                [ ! $move_dir ] && return 1
                [ -d $move_dir ] && break
            done
        }
        [ -d $move_dir ] && code_destination_path=$move_dir
    }
    [ -d $code_destination_path ] && {
        [ -f $code_destination_path/${arg2}_$read.tar.gz ] && rm -rf $code_destination_path/${arg2}_$read.tar.gz
        mv ${arg2}_$read.tar.gz $code_destination_path/${arg2}.tar.gz
        read -p "Unzip the code package Y/N?: " answer
        [ $answer = 'Y' ] && {
            cd $code_destination_path
            tar xvf ${arg2}.tar.gz
        }
    }
    return 0
}
export script_exe_path
function dit-hello {
    run_env_check
    echo "working..."
    env_name=$HOME"/.bashrc"
    script_exe_path=$DIT_PATH
    [ ! -f $env_name ] && echo "Create ENV file!" && touch $env_name
    add_env_path="export PATH=\"$script_exe_path:\$PATH\""
    escape_str=`echo $add_env_path |sed 's#\/#\\\/#g'`
    sed -i '/'^"$escape_str"$'/d' $env_name
    echo $add_env_path >>$env_name
    echo "name "$script_name
    [[ $script_name != dit && -d $script_exe_path ]] && {
        rm -rf $script_exe_path
        mkdir $script_exe_path
        cp $script $script_exe_path
        chmod +x $script_exe_path
    }
    $script comple -p=$script_exe_path -w
    dircfg -p $CFG_IN_DIR
    $script cfg --signature
    return 0
}
function get_script_path {
    start_spin
    self_path=`find /home -iname ${script_name##*/}`
    stop_spin
    [ $(echo $self_path |awk '{print NF}') -gt 1 ] && echo "!!!路径不唯一，请检查:" && echo "$self_path" && exit 1
    comple_path=${self_path%/*}
}
function dit-comple {
    option_check $arg2
    comple_dir=".$script_name"
    comple_file=$script_name-completion.bash
    [[ $arg2 = '-p' ]] && {
        [ ! -d $arg3 ] && echo "Please ensure that the path already exists!" && exit 1
        comple_path=$arg3
    } || {
        comple_path=$script_path
        echo "script_path  $script_path"
    }
    dit_path="$comple_path"
    [ -n "$script_exe_path" ] && dit_path="$script_exe_path"
    cat > $comple_path/$comple_file <<EOF
#/usr/bin/env bash
#@create:$(date) by skull
${script_name}_path="$dit_path/$script_name"
[ ! -f \$${script_name}_path ] && return
function define_complete {
    arg=''
    is_dir=0
    COMPREPLY=()
    case \$COMP_CWORD in
        1)
        arg=\$(grep -w ^"usage: \\\$script_name" \${${script_name}_path} |grep -o '\[.*\]' |sed -e 's/\[//g'|sed -e 's/\]//g')
        ;;
        *)
        if [[ \$COMP_CWORD == 2 ]]; then
            arg=\$(grep -w "^\\\$script_name \${COMP_WORDS[COMP_CWORD - 1]}" \${${script_name}_path} |grep -o '\[.*\]' |sed -e 's/\[//g'|sed -e 's/\]//g')
        elif [[ "\${COMP_WORDS[COMP_CWORD]}" =~ "-" ]]; then
            option="\${COMP_WORDS[1]}"
            main_option="\${COMP_WORDS[2]}"
            start_line=\$(grep -nw "^\\\$script_name \$option" \${${script_name}_path} |head -n 1 |cut -d: -f1 |xargs)
            main_option_start_line=\$(tail -n +"\$start_line" \${${script_name}_path} |grep  -nwE "^[[:space:]]{4}\$main_option" |head -n 1 |cut -d: -f1 |xargs)
            line_number=\$((start_line + main_option_start_line - 1))
            arg=\$(tail -n +"\$line_number" \${${script_name}_path} | awk -v main_option="\$main_option" '
                /^[ ]{4}[^[:space:]]/ {
                    if (\$1 == main_option) {
                        current_option = \$1
                        suboptions[current_option] = ""
                    }
                }
                /^\\s{8}-[a-zA-Z0-9]/ || /^\\s{8}--/ {
                    if (current_option != "") {
                        suboptions[current_option] = suboptions[current_option] " " \$1
                    }
                }
                /^^[ ]{4}[^[:space:]]/ && \$1 != main_option {
                    exit
                }
                END {
                    result = ""
                    for (option in suboptions) {
                        result = result suboptions[option] "\n"
                    }
                    print result
                }')
            if [[ ! "\$arg" =~ "\${COMP_WORDS[COMP_CWORD]}" ]] ;then
                arg=\$(grep -w "^\\\$script_name \${COMP_WORDS[1]}" \${${script_name}_path} |grep -o '\[.*\]' |sed -e 's/\[//g'|sed -e 's/\]//g')
            fi
        else
            arg=''
        fi
        if [[ -z "\$arg" ]]; then
            if [[ -d "\${COMP_WORDS[COMP_CWORD]%/*}" || -d "\${COMP_WORDS[COMP_CWORD]}" || -d "\${COMP_WORDS[COMP_CWORD - 1]}" ]]; then
                is_dir=1
            else
                arg=\$(la)
            fi
        fi
        ;;
    esac
    if [[ \$is_dir == 1 ]]; then
        compopt -o filenames -o nospace 2>/dev/null
        COMPREPLY=(\$(compgen -f -- "\${COMP_WORDS[COMP_CWORD]}"))
    else
        COMPREPLY=(\$(compgen -W "\$arg" -- \${COMP_WORDS[COMP_CWORD]}))
    fi
}
complete -F define_complete $script_name
EOF
    [ $? = 0 ] && echo -e "\n\e[32mThe completion file is created successfully!\e[0m"
    [[ ${EXEC_PARAMS[@]} =~ '-w' ]] && {
        add_env_path="source $comple_path/$comple_file"
        escape_str=`echo $add_env_path |sed 's#\/#\\\/#g'`
        sed -i '/'^"$escape_str"$'/d' ~/.bashrc
        echo $add_env_path >> ~/.bashrc && source ~/.bashrc
        chmod 777 $comple_path/$comple_file
        echo -e "Please execute \e[43msource ~/.bashrc\e[0m"
    }
    return 0
}
function dit-git {
    [[ ${EXEC_PARAMS[@]} =~ '-C' ]] && {
        ${@:1} |tee .$script_name/$REPO_DIFF
        return
    }
    readarray -t git_repo_dir < <(find . -type d -name ".git" | xargs -I {} dirname {})
    echo "$"$do_cmd" "$arg2"  @"$(date) >.$script_name/$REPO_DIFF
    for dir in "${git_repo_dir[@]}"; do
        echo -e "\r\n-- project  $dir\r\n" >>.$script_name/$REPO_DIFF
        git -C $dir ${@:2} >>.$script_name/$REPO_DIFF
    done
    return 0
}
UPDATE_URL="https://raw.githubusercontent.com/skullboyer/doit/main/doit"
VERSION_URL="https://raw.githubusercontent.com/skullboyer/doit/main/version"
UPGRADE_URL="https://raw.githubusercontent.com/skullboyer/doit/main/upgrade"
function dit-update {
    CURRENT_VERSION=$(sed -n '2p' ~/.$script_name/$script_name |awk -F 'ver:' '{print $2}')
    if hit_option '-g'; then
        cp ./out/release_dit ./release/doit
        echo $CURRENT_VERSION >./release/version
        echo "no care" >./release/upgrade
        [[ ${EXEC_PARAMS[@]} =~ '--force' ]] && echo "force" >./release/upgrade
        return 0
    fi
    [ $1 = '-b' ] && {
        local check_date="$CFG_IN_DIR/update_check.date"
        if [ -f "$check_date" ]; then
            last_date=$(cat "$check_date")
            today=$(date +"%Y-%m-%d")
            [ "$last_date" = "$today" ] && return
            sudo bash -c 'echo "$0" > "$1"' "$today" "$check_date"
        else
            today=$(date +"%Y-%m-%d")
            sudo bash -c 'echo "$0" > "$1"' "$today" "$check_date"
            return
        fi
        FORCED_UPGRADE=$(curl -s "$UPGRADE_URL")
        [ $last_cmd = '?' ] && echo "upgrade: "$FORCED_UPGRADE
        [[ $FORCED_UPGRADE != 'force' ]] && return
    }
    [ $1 = '-b' ] || echo "Checking for updates..."
    LATEST_VERSION=$(curl -s "$VERSION_URL")
    [ $last_cmd = '?' ] && echo "new: "$LATEST_VERSION
    [ $last_cmd = '?' ] && echo "now: "$CURRENT_VERSION
    compare_version $LATEST_VERSION $CURRENT_VERSION
    if [[ $? -eq 1 ]]; then
        read -p "New version available: updated? [Y/n]: " input
        [[ $input != 'Y' ]] && return 1
        echo "Updating..."
        curl -s -o "doit.tmp" "$UPDATE_URL"
        if [ $? -eq 0 ]; then
            mv "doit.tmp" ~/.$script_name/$script_name
            chmod +x ~/.$script_name/$script_name
            echo_c -g "Update successful. Please re-run the script."
            return 0
        else
            echo_c -r "Failed to download the update."
            rm -f "doit.tmp"
            return -1
        fi
    else
        [ $1 = '-b' ] || echo "Already up-to-date."
    fi
}
function cmd_check {
    [ ! -d .$script_name ] && mkdir .$script_name
    [[ ! $do_cmd ]] && {
        echo -e "\a\n!!! Please enter the correct command."
        exit 1
    } || {
        [ $do_cmd = "help" ] && help_info && exit 0
        [[ ${EXEC_PARAMS[@]} =~ 'help' ]] && sub_help $do_cmd && exit 0
    }
    arg=$(grep -n ^"usage: \$script_name" $script_name_with_path | grep -o '\[.*\]' |sed -e 's/\[//g'|sed -e 's/\]//g')
    result=$(echo $arg |grep -w $do_cmd)
    [[ ! $result && ! ${command_whitelist[@]} =~ $do_cmd ]] && {
        echo -e "\a\e[1;31m\n OH SHIT \n"
        exit -1
    }
}
function BEGIN {
    sudo rm -rf /usr/bin/python
    sudo ln -s /usr/bin/python2.7 /usr/bin/python
    [ $do_cmd = 'update' ] || $script_name-update -b
    handle_history_file_order
    run_env_check
    update_code_info
    echo "Start @"$(date)
    begin_time=$(date +%s.%3N)
}
function END {
    local reval=$?
    end_time=$(date +%s.%3N)
    execution_time=$(echo "$end_time - $begin_time" |bc)
    execution_times=$(echo "$execution_time" | cut -d. -f1)
    hours=$((execution_times / 3600))
    minutes=$((execution_times % 3600 / 60))
    seconds=$((execution_times % 60))
    milliseconds=$(echo "$execution_time" | cut -d. -f2 | sed 's/^0*//')
    milliseconds=$(printf "%03d" "$milliseconds")
    echo -e "\nDONE! "$(date) && echo "Elapsed Time: $hours:$minutes:$seconds.$milliseconds"
    local boundary=200
    [ $reval -eq 0 ] && {
        (echo -e "\n\e[42mSuccess!\e[0m"; prompt_tone 3 &)
    } || {
        [ $reval -lt $boundary ] && {
            (echo -e "\n\e[43mWarning!\e[0m"; prompt_tone 3 &)
        } || {
            [ $reval -gt $boundary ] && (echo -e "\n\e[41mERROR!\e[0m"; prompt_tone -1 &)
        }
    }
    [[ $last_cmd = '?' ]] || rm -f $DOT_DIT/*.tmp
    exit 0
}
function main {
    cmd_check
    options_check
    [[ $last_cmd = '$' ]] && exit 0
    BEGIN
    $script_name-$do_cmd $@
    END
}
main $@